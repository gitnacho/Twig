% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,spanish]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Twig-es}
\date{May 29, 2012}
\release{1.9.0}
\author{Traducido por Nacho Pacheco}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.14,0.14}{##1}}}
\def\PYG@tok@{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@gu{\let\PYG@ul=\underline\def\PYG@tc##1{\textcolor[rgb]{1.00,1.00,1.00}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.14,0.14}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.14,0.14}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.25,1.00,1.00}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.21,0.47,0.66}{##1}}}
\def\PYG@tok@l{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@cs{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.90,0.03,0.03}{##1}}\def\PYG@bc##1{\colorbox[rgb]{0.32,0.00,0.00}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.25,1.00,1.00}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.21,0.47,0.66}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.80,0.80,0.80}{##1}}}
\def\PYG@tok@cp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.80,0.16,0.16}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.35,0.60,0.10}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{1.00,1.00,1.00}{##1}}}
\def\PYG@tok@ni{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@ld{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@nl{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@nn{\let\PYG@ul=\underline\def\PYG@tc##1{\textcolor[rgb]{0.27,0.50,0.81}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.25,1.00,1.00}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.56,0.62}{##1}}}
\def\PYG@tok@nc{\let\PYG@ul=\underline\def\PYG@tc##1{\textcolor[rgb]{0.27,0.50,0.81}{##1}}}
\def\PYG@tok@nd{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.65,0.00}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.27,0.50,0.81}{##1}}}
\def\PYG@tok@nx{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@si{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@x{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.25,1.00,1.00}{##1}}}
\def\PYG@tok@py{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.25,1.00,1.00}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@gp{\def\PYG@tc##1{\textcolor[rgb]{0.67,0.67,0.67}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.21,0.47,0.66}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.56,0.62}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.21,0.47,0.66}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@g{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@err{\def\PYG@tc##1{\textcolor[rgb]{0.65,0.09,0.09}{##1}}\def\PYG@bc##1{\colorbox[rgb]{0.89,0.82,0.82}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.21,0.47,0.66}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.21,0.47,0.66}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.65,0.00}{##1}}}
\def\PYG@tok@n{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@p{\def\PYG@tc##1{\textcolor[rgb]{0.82,0.82,0.82}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.42,0.72,0.15}{##1}}}
\def\PYG@tok@se{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}
\def\PYG@tok@sd{\def\PYG@tc##1{\textcolor[rgb]{0.93,0.62,0.07}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\part{Introducción}
\label{intro:introduccion}\label{intro:twig}\label{intro::doc}
Esta es la documentación de \emph{Twig}, el flexible, rápido y seguro motor de plantillas para \emph{PHP}.

Si has estado expuesto a otros lenguajes de plantilla basados en texto, tal como \emph{Smarty, Django} o \emph{Jinja}, debes sentirte como en casa con \emph{Twig}. Es a la vez, un amigable ambiente para el diseñador y desarrollador apegado a los principios de \emph{PHP}, añadiendo útil funcionalidad a los entornos de plantillas.

Las características clave son...
\begin{itemize}
\item {} 
\emph{Rápido}: \emph{Twig} compila las plantillas hasta código \emph{PHP} regular optimizado. El costo general en comparación con código \emph{PHP} regular se ha reducido al mínimo.

\item {} 
\emph{Seguro}: \emph{Twig} tiene un modo de recinto de seguridad para evaluar el código de plantilla que no es confiable. Esto te permite utilizar \emph{Twig} como un lenguaje de plantillas para aplicaciones donde los usuarios pueden modificar el diseño de la plantilla.

\item {} 
\emph{Flexible}: \emph{Twig} es alimentado por flexibles analizadores léxico y sintáctico. Esto permite al desarrollador definir sus propias etiquetas y filtros personalizados, y crear su propio \emph{DSL}.

\end{itemize}


\chapter{Requisitos previos}
\label{intro:requisitos-previos}
\emph{Twig} necesita por lo menos \textbf{PHP 5.2.4} para funcionar.


\chapter{Instalando}
\label{intro:instalando}
Tienes varias formas de instalar \emph{Twig}. Si no estás seguro qué hacer, descarga el archivo comprimido (\code{tarball}).


\section{Instalando la versión comprimida}
\label{intro:instalando-la-version-comprimida}\begin{enumerate}
\item {} 
Descarga el archivo comprimido más reciente desde la \href{https://github.com/fabpot/Twig/tags}{página de descarga}

\item {} 
Descomprime el archivo

\item {} 
Mueve los archivos a algún lugar en tu proyecto

\end{enumerate}


\section{Instalando la versión de desarrollo}
\label{intro:instalando-la-version-de-desarrollo}\begin{enumerate}
\item {} 
Instala desde \emph{Subversión} o \emph{Git}

\item {} 
Para \emph{Git}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
git clone git://github.com/fabpot/Twig.git
\end{Verbatim}
\end{quote}

\item {} 
Para \emph{Subversión}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
svn co http://svn.twig-project.org/trunk/ twig
\end{Verbatim}
\end{quote}

\end{enumerate}


\section{Instalando el paquete \emph{PEAR}}
\label{intro:instalando-el-paquete-pear}\begin{enumerate}
\item {} 
Instala \emph{PEAR}

\item {} 
\code{pear channel-discover pear.twig-project.org}

\item {} 
\code{pear install twig/Twig} (o \code{pear install twig/Twig-beta})

\end{enumerate}


\section{Instalando vía \texttt{Composer}}
\label{intro:instalando-via-composer}\begin{enumerate}
\item {} 
Instala \code{composer} en tu proyecto:

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
curl -s http://getcomposer.org/installer \textbar{} php
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Crea un archivo \code{composer.json} en el directorio raíz de tu proyecto:

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{"require"}\PYG{o}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{"twig/twig"}\PYG{o}{:} \PYG{l+s+s2}{"1.*"}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Instala vía \code{composer}

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
php composer.phar install
\end{Verbatim}

\begin{notice}{note}{Nota:}
Si  quieres aprender más sobre \code{Composer}, la sintaxis del \code{compositor.json} y su uso,  puedes leer la \href{http://getcomposer.org/doc}{documentación en línea}.
\end{notice}


\section{Instalando la extensión \emph{C}}
\label{intro:instalando-la-extension-c}Nuevo en la versión 1.4: La extensión \emph{C} se añadió en Twig 1.4.
\emph{Twig} viene con una extensión \emph{C} que mejora el rendimiento del motor \emph{Twig} en tiempo de ejecución. La puedes instalar como cualquier otra extensión de \emph{PHP}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }\PYG{n+nb}{cd }ext/twig
\PYG{n+nv}{\PYGZdl{} }phpize
\PYG{n+nv}{\PYGZdl{} }./configure
\PYG{n+nv}{\PYGZdl{} }make
\PYG{n+nv}{\PYGZdl{} }make install
\end{Verbatim}

Por último, activa la extensión en tu archivo de configuración \code{php.ini}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+na}{extension}\PYG{o}{=}\PYG{l+s}{twig.so}
\end{Verbatim}

Y a partir de ahora, \emph{Twig} compilará automáticamente tus plantillas para tomar ventaja de la extensión \emph{C}. Ten en cuenta que esta extensión no sustituye el código \emph{PHP}, solamente proporciona una versión optimizada del método \code{Twig\_Template::getAttribute()}.

\begin{notice}{tip}{Truco:}
En \emph{Windows} también, puedes simplemente descargar e instalar una extensión \href{https://github.com/stealth35/stealth35.github.com/downloads}{DLL preconstruida}.
\end{notice}


\chapter{Uso básico de la \emph{API}}
\label{intro:uso-basico-de-la-api}
Esta sección te ofrece una breve introducción a la \emph{API PHP} de \emph{Twig}.

El primer paso para utilizar \emph{Twig} es registrar su cargador automático:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{require\PYGZus{}once} \PYG{l+s+s1}{'/ruta/a/lib/Twig/Autoloader.php'}\PYG{p}{;}
\PYG{n+nx}{Twig\PYGZus{}Autoloader}\PYG{o}{::}\PYG{n+na}{register}\PYG{p}{();}
\end{Verbatim}

Sustituye \code{/ruta/a/lib/} con la ruta que utilizaste en la instalación de \emph{Twig}.

\begin{notice}{note}{Nota:}
\emph{Twig} sigue la convención de nombres de \emph{PEAR} para sus clases, lo cual significa que puedes integrar fácilmente las clases de \emph{Twig} cargándolo en tu propio cargador automático.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}loader} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Loader\PYGZus{}String}\PYG{p}{();}
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}

\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{render}\PYG{p}{(}\PYG{l+s+s1}{'Hello \PYGZob{}\PYGZob{} name \PYGZcb{}\PYGZcb{}!'}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'name'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'Fabien'}\PYG{p}{));}
\end{Verbatim}

\emph{Twig} utiliza un cargador (\code{Twig\_Loader\_String}) para buscar las plantillas, y un entorno (\code{Twig\_Environment}) para almacenar la configuración.

El método \code{render()} carga la plantilla pasada como primer argumento y la reproduce con las variables pasadas como segundo argumento.

Debido a que las plantillas generalmente se guardan en el sistema de archivos, \emph{Twig} también viene con un cargador del sistema de archivos:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}loader} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Loader\PYGZus{}Filesystem}\PYG{p}{(}\PYG{l+s+s1}{'/ruta/a/templates'}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'cache'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'/ruta/a/compilation\PYGZus{}cache'}\PYG{p}{,}
\PYG{p}{));}

\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{render}\PYG{p}{(}\PYG{l+s+s1}{'index.html'}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'name'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'Fabien'}\PYG{p}{));}
\end{Verbatim}


\part{\emph{Twig} para diseñadores de plantillas}
\label{templates:twig-para-disenadores-de-plantillas}\label{templates:dll-preconstruida}\label{templates::doc}
Este documento describe la sintaxis y semántica del motor de plantillas y será muy útil como referencia para quién esté creando plantillas \emph{Twig}.


\chapter{Sinopsis}
\label{templates:sinopsis}
Una plantilla simplemente es un archivo de texto. Esta puede generar cualquier formato basado en texto (\emph{HTML}, \emph{XML}, \emph{CSV}, \emph{LaTeX}, etc.) No tiene una extensión específica, \code{.html} o \code{.xml} están muy bien.

Una plantilla contiene \textbf{variables} o \textbf{expresiones}, las cuales se reemplazan por valores cuando se evalúa la plantilla, y las \textbf{etiquetas}, controlan la lógica de la plantilla.

A continuación mostramos una plantilla mínima que ilustra algunos conceptos básicos. Veremos los detalles más adelante en este documento:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}!DOCTYPE html\textgreater{}}
\PYG{n+nt}{\textless{}html}\PYG{n+nt}{\textgreater{}}
    \PYG{n+nt}{\textless{}head}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}title}\PYG{n+nt}{\textgreater{}}My Webpage\PYG{n+nt}{\textless{}/title\textgreater{}}
    \PYG{n+nt}{\textless{}/head\textgreater{}}
    \PYG{n+nt}{\textless{}body}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}ul} \PYG{n+na}{id=}\PYG{l+s}{"navigation"}\PYG{n+nt}{\textgreater{}}
        \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{item} \PYG{k}{in} \PYG{n+nv}{navigation} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
            \PYG{n+nt}{\textless{}li}\PYG{n+nt}{\textgreater{}}\PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{item}\PYG{n+nv}{.href} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{l+s}{"}\PYG{n+nt}{\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{item}\PYG{n+nv}{.caption} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{n+nt}{\textless{}/a\textgreater{}}\PYG{n+nt}{\textless{}/li\textgreater{}}
        \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
        \PYG{n+nt}{\textless{}/ul\textgreater{}}

        \PYG{n+nt}{\textless{}h1}\PYG{n+nt}{\textgreater{}}My Webpage\PYG{n+nt}{\textless{}/h1\textgreater{}}
        \PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{a\PYGZus{}variable} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
    \PYG{n+nt}{\textless{}/body\textgreater{}}
\PYG{n+nt}{\textless{}/html\textgreater{}}
\end{Verbatim}

Hay dos tipos de delimitadores: \code{\{\% ... \%\}} y \code{\{\{ ... \}\}}. El primero se utiliza para ejecutar declaraciones como bucles \code{for}, el último imprime en la plantilla el resultado de una expresión.


\chapter{Integrando con \emph{IDEs}}
\label{templates:integrando-con-ides}
Los \emph{IDEs} modernos son compatibles con el resaltado de sintaxis y autocompletado en una amplia gama de lenguajes.
\begin{itemize}
\item {} 
\emph{Textmate} vía el \href{https://github.com/Anomareh/PHP-Twig.tmbundle}{paquete Twig}

\item {} 
\emph{Vim} vía el \href{http://jinja.pocoo.org/2/documentation/integration}{complemento de sintaxis Jinja}

\item {} 
\emph{Netbeans} vía el \href{http://plugins.netbeans.org/plugin/37069/php-twig}{complemento de sintaxis Twig}

\item {} 
\emph{PhpStorm} (nativo desde la versión 2.1)

\item {} 
\emph{Eclipse} vía el \href{https://github.com/pulse00/Twig-Eclipse-Plugin}{complemento Twig}

\item {} 
\emph{Sublime Text} vía el \href{https://github.com/Anomareh/PHP-Twig.tmbundle}{paquete Twig}

\item {} 
\emph{GtkSourceView} vía el \href{https://github.com/gabrielcorpse/gedit-twig-template-language}{Twig language definition} (usado por \emph{gedit} y otros proyectos)

\item {} 
\emph{Coda} y \emph{SubEthaEdit} vía el \href{https://github.com/bobthecow/Twig-HTML.mode}{Twig syntax mode}

\end{itemize}


\chapter{Variables}
\label{templates:variables}
La aplicación pasa variables a las plantillas para que puedas combinarlas en la plantilla. Las variables pueden tener atributos o elementos en ellas a los cuales puedes acceder también. Cómo se ve una variable, en gran medida, depende de la aplicación que la proporcione.

Puedes utilizar un punto (\code{.}) para acceder a los atributos de una variable (métodos o propiedades de un objeto \emph{PHP}, o elementos de una matriz \emph{PHP}), o la así llamada sintaxis de ``subíndice'' (\code{{[}{]}}).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{foo}\PYG{n+nv}{.bar} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{foo}\PYG{o}{[}\PYG{l+s+s1}{'bar'}\PYG{o}{]} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Es importante saber que las llaves no son parte de la variable, sino de la declaración de impresión. Si accedes a variables dentro de las etiquetas no las envuelvas con llaves.
\end{notice}

Si no existe una variable o atributo, recibirás un valor \code{nulo} cuando la opción \code{strict\_variables} está ajustada a \code{false}, de lo contrario \emph{Twig} lanzará un error (consulta las {\hyperref[api:environment-options]{\emph{opciones de entorno}}} (\autopageref*{api:environment-options})).
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Implementación}

\medskip


Por razones de conveniencia \code{foo.bar} hace lo siguiente en la capa \emph{PHP}:
\begin{itemize}
\item {} 
Comprueba si \code{foo} es una matriz y \code{bar} un elemento válido;

\item {} 
si no, y si \code{foo} es un objeto, comprueba que \code{bar} es una propiedad válida;

\item {} 
si no, y si \code{foo} es un objeto, comprueba que \code{bar} es un método válido (incluso si \code{bar} es el constructor --- usa \code{\_\_construct()} en su lugar);

\item {} 
si no, y si \code{foo} es un objeto, comprueba que \code{getBar} es un método válido;

\item {} 
si no, y si \code{foo} es un objeto, comprueba que \code{isBar} es un método válido;

\item {} 
si no, devuelve un valor \code{null}.

\end{itemize}

\code{foo{[}'bar'{]}} por el contrario sólo trabaja con matrices \emph{PHP}:
\begin{itemize}
\item {} 
Comprueba si \code{foo} es una matriz y \code{bar} un elemento válido;

\item {} 
si no, devuelve un valor \code{null}.

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}

\begin{notice}{note}{Nota:}
Si deseas obtener un atributo dinámico en una variable, utiliza la función {\hyperref[functions/attribute::doc]{\emph{attribute}}} (\autopageref*{functions/attribute::doc}) en su lugar.
\end{notice}


\section{Variables globales}
\label{templates:variables-globales}
Las siguientes variables siempre están disponibles en las plantillas:
\begin{itemize}
\item {} 
\code{\_self}: hace referencia a la plantilla actual;

\item {} 
\code{\_context}: hace referencia al contexto actual;

\item {} 
\code{\_charset}: hace referencia al juego de caracteres actual.

\end{itemize}


\section{Definiendo variables}
\label{templates:definiendo-variables}
Puedes asignar valores a las variables dentro de los bloques de código. Las asignaciones usan la etiqueta {\hyperref[tags/set::doc]{\emph{set}}} (\autopageref*{tags/set::doc}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{l+s+s1}{'foo'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{Filtros}
\label{templates:filtros}
Los \textbf{filtros} pueden modificar variables. Los filtros están separados de la variable por un símbolo de tubo (\code{\textbar{}}) y pueden tener argumentos opcionales entre paréntesis. Puedes encadenar múltiples filtros. La salida de un filtro se aplica al siguiente.

El siguiente ejemplo elimina todas las etiquetas \emph{HTML} del \code{name} y lo formatea como nombre propio:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{name}\PYG{o}{\textbar{}}\PYG{n+nf}{striptags}\PYG{o}{\textbar{}}\PYG{n+nf}{title} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Los filtros que aceptan argumentos llevan paréntesis en torno a los argumentos. Este ejemplo unirá una lista con comas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{list}\PYG{o}{\textbar{}}\PYG{n+nf}{join}\PYG{o}{(}\PYG{l+s+s1}{', '}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Para aplicar un filtro en una sección de código, envuélvelo con la etiqueta {\hyperref[tags/filter::doc]{\emph{filter}}} (\autopageref*{tags/filter::doc}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{filter} \PYG{n+nf}{upper} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{  Este texto cambia a mayúsculas}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfilter} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Ve a la página de {\hyperref[filters/index::doc]{\emph{filtros}}} (\autopageref*{filters/index::doc}) para aprender más acerca de los filtros incorporados.


\chapter{Funciones}
\label{templates:funciones}
Las funciones se pueden llamar para generar contenido. Las funciones son llamadas por su nombre seguido de paréntesis (\code{()}) y pueden tener argumentos.

Por ejemplo, la función \code{range} devuelve una lista que contiene una progresión aritmética de números enteros:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{n+nv}{range}\PYG{o}{(}\PYG{l+m}{0}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{i} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{,}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Ve a la página {\hyperref[functions/index::doc]{\emph{funciones}}} (\autopageref*{functions/index::doc}) para aprender más acerca de las funciones incorporadas.


\chapter{Estructuras de control}
\label{templates:estructuras-de-control}
Una estructura de control se refiere a todas esas cosas que controlan el flujo de un programa --- condicionales (es decir, \code{if}/\code{elseif}/\code{else}), bucles \code{for}, así como cosas tales como bloques. Las estructuras de control aparecen dentro de bloques \code{\{\% ... \%\}}.

Por ejemplo, para mostrar una lista de usuarios provista en una variable llamada \code{users}, usa la etiqueta {\hyperref[tags/for::doc]{\emph{for}}} (\autopageref*{tags/for::doc}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}h1\textgreater{}Members\textless{}/h1\textgreater{}}
\PYG{x}{\textless{}ul\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{\textless{}/ul\textgreater{}}
\end{Verbatim}

Puedes utilizar la etiqueta {\hyperref[tags/if::doc]{\emph{if}}} (\autopageref*{tags/if::doc}) para probar una expresión:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{users}\PYG{o}{\textbar{}}\PYG{n+nf}{length} \PYG{o}{\textgreater{}} \PYG{l+m}{0} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}ul\textgreater{}}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{            \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}/ul\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Ve a la página {\hyperref[tags/index::doc]{\emph{etiquetas}}} (\autopageref*{tags/index::doc}) para aprender más acerca de las etiquetas incorporadas.


\chapter{Comentarios}
\label{templates:comentarios}
Para comentar parte de una línea en una plantilla, utiliza la sintaxis de comentario \code{\{\# ... \#\}}. Esta es útil para depuración o para agregar información para los diseñadores de otra plantilla o para ti mismo:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} nota: inhabilitado en la plantilla porque ya no se utiliza}
\PYG{c}{    \PYGZob{}\PYGZpc{} for user in users \PYGZpc{}\PYGZcb{}}
\PYG{c}{        ...}
\PYG{c}{    \PYGZob{}\PYGZpc{} endfor \PYGZpc{}\PYGZcb{}}
\PYG{c}{\PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{Incluyendo otras plantillas}
\label{templates:incluyendo-otras-plantillas}
La etiqueta {\hyperref[tags/include::doc]{\emph{include}}} (\autopageref*{tags/include::doc}) es útil para incluir una plantilla y devolver el contenido reproducido de esa plantilla a la actual:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'sidebar.html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

De manera predeterminada se pasa el contexto actual a las plantillas incluidas.

El contexto que se pasa a la plantilla incluida incorpora las variables definidas en la plantilla:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{box} \PYG{k}{in} \PYG{n+nv}{boxes} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s2}{"render\PYGZus{}box.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La plantilla incluida \code{render\_box.html} es capaz de acceder a \code{box}.

El nombre de archivo de la plantilla depende del gestor de plantillas. Por ejemplo, el \code{Twig\_Loader\_Filesystem} te permite acceder a otras plantillas, dando el nombre del archivo. Puedes acceder a plantillas en subdirectorios con una barra inclinada:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s2}{"sections/articles/sidebar.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Este comportamiento depende de la aplicación en que integres \emph{Twig}.


\chapter{Herencia en plantillas}
\label{templates:herencia-en-plantillas}
La parte más poderosa de \emph{Twig} es la herencia entre plantillas. La herencia de plantillas te permite crear un ``esqueleto'' de plantilla base que contenga todos los elementos comunes de tu sitio y define los \textbf{bloques} que las plantillas descendientes pueden sustituir.

Suena complicado pero es muy básico. Es más fácil entenderlo si comenzamos con un ejemplo.

Vamos a definir una plantilla base, \code{base.html}, la cual define el esqueleto de un documento \emph{HTML} simple que puedes usar para una sencilla página de dos columnas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}!DOCTYPE html\textgreater{}}
\PYG{n+nt}{\textless{}html}\PYG{n+nt}{\textgreater{}}
    \PYG{n+nt}{\textless{}head}\PYG{n+nt}{\textgreater{}}
        \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{head} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
            \PYG{n+nt}{\textless{}link} \PYG{n+na}{rel=}\PYG{l+s}{"stylesheet"} \PYG{n+na}{href=}\PYG{l+s}{"style.css"} \PYG{n+nt}{/\textgreater{}}
            \PYG{n+nt}{\textless{}title}\PYG{n+nt}{\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}} - My Webpage\PYG{n+nt}{\textless{}/title\textgreater{}}
        \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
    \PYG{n+nt}{\textless{}/head\textgreater{}}
    \PYG{n+nt}{\textless{}body}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}div} \PYG{n+na}{id=}\PYG{l+s}{"content"}\PYG{n+nt}{\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{n+nt}{\textless{}/div\textgreater{}}
        \PYG{n+nt}{\textless{}div} \PYG{n+na}{id=}\PYG{l+s}{"footer"}\PYG{n+nt}{\textgreater{}}
            \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{footer} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
                \PYG{n+ni}{\&copy;} Copyright 2011 by \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"http://dominio.invalido/"}\PYG{n+nt}{\textgreater{}}
                                             tú
                                         \PYG{n+nt}{\textless{}/a\textgreater{}}.
            \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
        \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}/body\textgreater{}}
\PYG{n+nt}{\textless{}/html\textgreater{}}
\end{Verbatim}

En este ejemplo, las etiquetas {\hyperref[tags/block::doc]{\emph{block}}} (\autopageref*{tags/block::doc}) definen cuatro bloques que las plantillas herederas pueden rellenar. Todas las etiquetas \code{block} le dicen al motor de plantillas que una plantilla heredera puede sustituir esas porciones de la plantilla.

Una plantilla hija podría tener este aspecto:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{x}{Index}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{head} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{parent}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{    \textless{}style type="text/css"\textgreater{}}
\PYG{x}{        .important }\PYG{x}{\PYGZob{}}\PYG{x}{ color: \PYGZsh{}336699; \PYGZcb{}}
\PYG{x}{    \textless{}/style\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}h1\textgreater{}Index\textless{}/h1\textgreater{}}
\PYG{x}{    \textless{}p class="important"\textgreater{}}
\PYG{x}{        Welcome on my awesome homepage.}
\PYG{x}{    \textless{}/p\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Aquí, la clave es la etiqueta {\hyperref[tags/extends::doc]{\emph{extends}}} (\autopageref*{tags/extends::doc}). Esta le dice al motor de plantillas que esta plantilla ``extiende'' otra plantilla. Cuando el sistema de plantillas evalúa esta plantilla, en primer lugar busca la plantilla padre. La etiqueta \code{extends} debe ser la primera etiqueta en la plantilla.

Ten en cuenta que debido a que la plantilla heredera no define el bloque \code{footer}, en su lugar se utiliza el valor de la plantilla padre.

Es posible reproducir el contenido del bloque padre usando la función {\hyperref[functions/parent::doc]{\emph{parent}}} (\autopageref*{functions/parent::doc}). Esta devuelve el resultado del bloque padre:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}h3\textgreater{}Table Of Contents\textless{}/h3\textgreater{}}
\PYG{x}{    ...}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{parent}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{tip}{Truco:}
La página de documentación para la etiqueta {\hyperref[tags/extends::doc]{\emph{extends}}} (\autopageref*{tags/extends::doc}) describe características más avanzadas como el anidamiento de bloques, ámbito, herencia dinámica, y herencia condicional.
\end{notice}

\begin{notice}{note}{Nota:}
\emph{Twig} también es compatible con herencia múltiple por medio del así llamado reuso horizontal con la ayuda de la etiqueta {\hyperref[tags/use::doc]{\emph{use}}} (\autopageref*{tags/use::doc}). Esta es una característica que casi nunca se necesita en las plantillas normales.
\end{notice}


\chapter{Escapando \emph{HTML}}
\label{templates:escapando-html}
Cuando generas \emph{HTML} desde plantillas, siempre existe el riesgo de que una variable incluya caracteres que afecten el \emph{HTML} resultante. Hay dos enfoques: escapar cada variable manualmente o de manera predeterminada escapar todo automáticamente.

\emph{Twig} apoya ambos, el escape automático está habilitado por omisión.

\begin{notice}{note}{Nota:}
El escape automático sólo se admite si has habilitado la extensión \emph{escaper} (el cual es el valor predeterminado).
\end{notice}


\section{Trabajando con el escape manual}
\label{templates:trabajando-con-el-escape-manual}
Si está habilitado el escape manual es \textbf{tu} responsabilidad escapar las variables si es necesario. ¿Qué escapar? Si tienes una variable que \emph{puede} incluir cualquiera de los siguientes caracteres (\code{\textgreater{}}, \code{\textless{}}, \code{\&} o \code{"}) \textbf{tienes} que escaparla a menos que la variable contenga \emph{HTML} bien formado y sea de confianza. El escape trabaja \emph{entubando} la variable a través del filtro \code{\textbar{}e}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e}\PYG{o}{(}\PYG{l+s+s1}{'js'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}


\section{Trabajando con escape automático}
\label{templates:trabajando-con-escape-automatico}
Ya sea que el escape automático esté habilitado o no, puedes marcar una sección de una plantilla para que sea escapada o no utilizando la etiqueta {\hyperref[tags/autoescape::doc]{\emph{autoescape}}} (\autopageref*{tags/autoescape::doc}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{k+kp}{true} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    Todo en este bloque se va a escapar automáticamente}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{Escapando}
\label{templates:escapando}
A veces es deseable e incluso necesario contar con que \emph{Twig} omita partes que de lo contrario manejaría como variables o bloques. Por ejemplo, si utilizas la sintaxis predeterminada y deseas utilizar \code{\{\{} como cadena sin procesar en la plantilla y no iniciar una variable, tienes que usar un truco.

La forma más sencilla es extraer la variable del delimitador (\code{\{\{}) usando una expresión variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'\PYGZob{}\PYGZob{}'} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Para secciones mayores tiene sentido marcar un bloque como {\hyperref[tags/raw::doc]{\emph{raw}}} (\autopageref*{tags/raw::doc}).


\chapter{Macros}
\label{templates:macros}
Las macros son comparables con funciones en lenguajes de programación regulares. Son útiles para reutilizar \emph{HTML} usado frecuentemente para no repetirlos tú mismo.

Una macro se define a través de la etiqueta {\hyperref[tags/macro::doc]{\emph{macro}}} (\autopageref*{tags/macro::doc}). Aquí está un pequeño ejemplo (más tarde llamada \code{forms.html}) de una macro que pinta un elemento de formulario:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{macro} \PYG{n+nv}{input}\PYG{o}{(}\PYG{n+nv}{name}\PYG{o}{,} \PYG{n+nv}{value}\PYG{o}{,} \PYG{n+nv}{type}\PYG{o}{,} \PYG{n+nv}{size}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}input type="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{type}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'text'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             name="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{name} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             value="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{value}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             size="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{size}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+m}{2}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{" /\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endmacro} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Puedes definir macros en cualquier plantilla, y necesitas ``importarlas'' con la etiqueta {\hyperref[tags/import::doc]{\emph{import}}} (\autopageref*{tags/import::doc}) antes de poder usarlas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{import} \PYG{l+s+s2}{"formularios.html"} \PYG{k}{as} \PYG{n+nv}{forms} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{x}{\textless{}p\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{forms}\PYG{n+nv}{.input}\PYG{o}{(}\PYG{l+s+s1}{'username'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/p\textgreater{}}
\end{Verbatim}

Alternativamente, puedes importar nombres de macros individuales desde una plantilla al espacio de nombres actual vía la etiqueta {\hyperref[tags/from::doc]{\emph{from}}} (\autopageref*{tags/from::doc}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{importa} \PYG{n+nv}{el} \PYG{n+nv}{input} \PYG{n+nv}{de} \PYG{l+s+s1}{'forms.html'} \PYG{n+nv}{como} \PYG{n+nv}{input\PYGZus{}field} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{x}{\textless{}dl\textgreater{}}
\PYG{x}{    \textless{}dt\textgreater{}Username\textless{}/dt\textgreater{}}
\PYG{x}{    \textless{}dd\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{input\PYGZus{}field}\PYG{o}{(}\PYG{l+s+s1}{'username'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/dd\textgreater{}}
\PYG{x}{    \textless{}dt\textgreater{}Password\textless{}/dt\textgreater{}}
\PYG{x}{    \textless{}dd\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{input\PYGZus{}field}\PYG{o}{(}\PYG{l+s+s1}{'password'}\PYG{o}{,} \PYG{l+s+s1}{''}\PYG{o}{,} \PYG{l+s+s1}{'password'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/dd\textgreater{}}
\PYG{x}{\textless{}/dl\textgreater{}}
\end{Verbatim}


\chapter{Expresiones}
\label{templates:expresiones}
\emph{Twig} acepta expresiones en cualquier parte. Estas funcionan de manera muy similar a \emph{PHP} regular e incluso si no estás trabajando con \emph{PHP} te debes sentir cómodo con estas.

\begin{notice}{note}{Nota:}
La precedencia de los operadores es la siguiente, mostrando los operadores de menor precedencia en primer lugar: \code{b-and}, \code{b-xor}, \code{b-or}, \code{or}, \code{and},
\code{==}, \code{!=}, \code{\textless{}}, \code{\textgreater{}}, \code{\textgreater{}=}, \code{\textless{}=}, \code{in}, \code{..}, \code{+},
\code{-}, \code{\textasciitilde{}}, \code{*}, \code{/}, \code{//}, \code{\%}, \code{is}, and \code{**}.
\end{notice}


\section{Literales}
\label{templates:literales}Nuevo en la versión 1.5: El soporte para codificar claves como nombres y expresiones se añadió en \emph{Twig} 1.5.
La forma más simple de las expresiones son literales. Los literales son representaciones para tipos \emph{PHP}, tal como cadenas, números y matrices. Existen los siguientes literales:
\begin{itemize}
\item {} 
\code{"Hello World"}: Todo lo que esté entre comillas simples o dobles es una cadena. Son útiles cuando necesitas una cadena en la plantilla (por ejemplo, como argumentos para llamadas a función, filtros o simplemente para extender o incluir una plantilla).

\item {} 
\code{42} / \code{42.23}: Números enteros y números en coma flotante se crean tan sólo escribiendo el número. Si está presente un punto es un número en coma flotante, de lo contrario es un número entero.

\item {} 
\code{{[}"foo", "bar"{]}}: Las matrices se definen por medio de una secuencia de expresiones separadas por una coma (\code{,}) y envueltas entre paréntesis cuadrados (\code{{[}{]}}).

\item {} 
\code{\{"foo": "bar"\}}: Los valores \code{hash} se definen con una lista de claves y valores separados por una coma (\code{,}) y envueltos entre llaves (\code{\{\}}).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} claves como cadena \PYGZsh{}\PYGZcb{}}
\PYG{x}{\PYGZob{}}\PYG{x}{ 'foo': 'foo', 'bar': 'bar' \PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} claves como nombres (equivalente al hash anterior) -- a partir}
\PYG{c}{   de Twig 1.5 \PYGZsh{}\PYGZcb{}}
\PYG{x}{\PYGZob{}}\PYG{x}{ foo: 'foo', bar: 'bar' \PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} keys as integer \PYGZsh{}\PYGZcb{}}
\PYG{x}{\PYGZob{}}\PYG{x}{ 2: 'foo', 4: 'bar' \PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} claves como expresiones (la expresión se debe encerrar entre}
\PYG{c}{   paréntesis) -- a partir de Twig 1.5 \PYGZsh{}\PYGZcb{}}
\PYG{x}{\PYGZob{}}\PYG{x}{ (1 + 1): 'foo', (a \PYGZti{} 'b'): 'bar' \PYGZcb{}}
\end{Verbatim}

\item {} 
\code{true} / \code{false}: \code{true} representa el valor verdadero, \code{false} representa el valor falso.

\item {} 
\code{null}: \code{null} no representa un valor específico. Este es el valor devuelto cuando una variable no existe. \code{none} es un alias para \code{null}.

\end{itemize}

Los arreglos y \code{hashes} se pueden anidar:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{o}{\PYGZob{}}\PYG{l+s+s2}{"foo"}\PYG{o}{:} \PYG{l+s+s2}{"bar"}\PYG{o}{\PYGZcb{}}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\section{Matemáticas}
\label{templates:matematicas}
\emph{Twig} te permite calcular valores. Esto no suele ser útil en las plantillas, pero existe por el bien de la integridad. Admite los siguientes operadores:
\begin{itemize}
\item {} 
\code{+}: Suma dos objetos (los operandos se convierten a números). \code{\{\{
1 + 1 \}\}} is \code{2}.

\item {} 
\code{-}: Sustrae el segundo número del primero. \code{\{\{ 3 - 2 \}\}} es \code{1}.

\item {} 
\code{/}: Divide dos números. El valor devuelto será un número en coma flotante. \code{\{\{ 1 / 2 \}\}} es \code{\{\{ 0.5 \}\}}.

\item {} 
\code{\%}: Calcula el residuo de una división entera. \code{\{\{ 11 \% 7 \}\}} es \code{4}.

\item {} 
\code{//}: Divide dos números y devuelve el resultado entero truncado. \code{\{\{
20 // 7 \}\}} is \code{2}.

\item {} 
\code{*}: Multiplica el operando de la izquierda con el de la derecha. \code{\{\{ 2 * 2 \}\}} devolverá \code{4}.

\item {} 
\code{**}: Eleva el operando izquierdo a la potencia del operando derecho. \code{\{\{ 2 ** 3 \}\}} would return \code{8}.

\end{itemize}


\section{Lógica}
\label{templates:logica}
Puedes combinar varias expresiones con los siguientes operadores:
\begin{itemize}
\item {} 
\code{and}: Devuelve \code{true} si ambos operandos izquierdo y derecho son \code{true}.

\item {} 
\code{or}: Devuelve \code{true} si el operando izquierdo o derecho es \code{true}.

\item {} 
\code{not}: Niega una declaración.

\item {} 
\code{(expr)}: Agrupa una expresión.

\end{itemize}

\begin{notice}{note}{Nota:}
\emph{Twig} además es compatible con operadores a nivel de bits (\code{b-and}, \code{b-xor}, and \code{b-or}).
\end{notice}


\section{Comparaciones}
\label{templates:comparaciones}
Los siguientes operadores de comparación son compatibles con cualquier expresión: \code{==},
\code{!=}, \code{\textless{}}, \code{\textgreater{}}, \code{\textgreater{}=}, y \code{\textless{}=}.


\section{Operador de contención}
\label{templates:operador-de-contencion}
El operador \code{in} realiza la prueba de contención.

Esta devuelve \code{true} si el operando de la izquierda figura entre los de la derecha:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} devuelve true \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+m}{1} \PYG{k}{in} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{]} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'cd'} \PYG{k}{in} \PYG{l+s+s1}{'abcde'} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{tip}{Truco:}
Puedes utilizar este filtro para realizar una prueba de contención en cadenas, arreglos u objetos que implementan la interfaz \code{Traversable}.
\end{notice}

Para llevar a cabo una prueba negativa, utiliza el operador \code{not in}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{l+m}{1} \PYG{k}{not} \PYG{k}{in} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} es equivalente a \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{k}{not} \PYG{o}{(}\PYG{l+m}{1} \PYG{k}{in} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{]}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\section{Operador de prueba}
\label{templates:operador-de-prueba}
El operador \code{is} realiza pruebas. Puedes utilizar las pruebas para comprobar una variable con una expresión común. El operando de la derecha es el nombre de la prueba:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} averigua si una variable es impar \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{nombre} \PYG{k}{is} \PYG{n+nf}{odd} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Las pruebas también pueden aceptar argumentos:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nb}{loop}\PYG{n+nv}{.index} \PYG{k}{is} \PYG{n+nf}{divisibleby}\PYG{o}{(}\PYG{l+m}{3}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Puedes negar las pruebas usando el operador \code{is not}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nb}{loop}\PYG{n+nv}{.index} \PYG{k}{is} \PYG{k}{not} \PYG{n+nf}{divisibleby}\PYG{o}{(}\PYG{l+m}{3}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} es equivalente a \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{k}{not} \PYG{o}{(}\PYG{n+nb}{loop}\PYG{n+nv}{.index} \PYG{k}{is} \PYG{n+nf}{divisibleby}\PYG{o}{(}\PYG{l+m}{3}\PYG{o}{)}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Ve a la página {\hyperref[tests/index::doc]{\emph{Probando}}} (\autopageref*{tests/index::doc}) para aprender más sobre las pruebas integradas.


\section{Otros operadores}
\label{templates:otros-operadores}
Los siguientes operadores son muy útiles pero no encajan en ninguna de las otras dos categorías:
\begin{itemize}
\item {} 
\code{..}: Crea una secuencia basada en el operando antes y después del operador (esta sólo es pura azúcar sintáctica para la función {\hyperref[functions/range::doc]{\emph{range}}} (\autopageref*{functions/range::doc})).

\item {} 
\code{\textbar{}}: Aplica un filtro.

\item {} 
\code{\textasciitilde{}}: Convierte todos los operandos en cadenas y los concatena. \code{\{\{ "Hello " \textasciitilde{} name \textasciitilde{} "!" \}\}} debería devolver (suponiendo que \code{name} es \code{'John'}) \code{Hello John!}.

\item {} 
\code{.}, \code{{[}{]}}: Obtiene un atributo de un objeto.

\item {} 
\code{?:}: El operador ternario de \emph{PHP}: \code{\{\{ foo ? 'yes' : 'no' \}\}}

\end{itemize}


\section{Interpolando cadenas}
\label{templates:interpolando-cadenas}Nuevo en la versión 1.5: La interpolación de cadenas se añadió en \emph{Twig} 1.5.
La interpolación de cadena (\emph{\#\{expresión\}}) permite que cualquier expresión válida aparezca
dentro de una cadena. El resultado de la evaluación esa expresión se inserta en la cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"foo \PYGZsh{}\PYGZob{}bar\PYGZcb{} baz"} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"foo \PYGZsh{}\PYGZob{}1 + 2\PYGZcb{} baz"} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}


\chapter{Controlando el espacio en blanco}
\label{templates:controlando-el-espacio-en-blanco}Nuevo en la versión 1.1: La etiqueta para controlar el nivel de los espacios en blanco se añadió en la \emph{Twig} 1.1.
La primer nueva línea después de una etiqueta de plantilla se elimina automáticamente (como en \emph{PHP}). El motor de plantillas no modifica el espacio en blanco, por lo tanto cada espacio en blanco (espacios, tabuladores, nuevas líneas, etc.) se devuelve sin cambios.

Utiliza la etiqueta \code{spaceless} para quitar los espacios en blanco entre las etiquetas \emph{HTML}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{spaceless} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}div\textgreater{}}
\PYG{x}{        \textless{}strong\textgreater{}foo\textless{}/strong\textgreater{}}
\PYG{x}{    \textless{}/div\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endspaceless} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} Producirá \textless{}div\textgreater{}\textless{}strong\textgreater{}foo\textless{}/strong\textgreater{}\textless{}/div\textgreater{} \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Además de la etiqueta \code{spaceless} también puedes controlar los espacios en blanco a nivel de etiquetas. Utilizando el modificador de control de los espacios en blanco en tus etiquetas, puedes recortar los espacios en blanco en ambos extremos:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{value} \PYG{o}{=} \PYG{l+s+s1}{'no spaces'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c}{\PYGZob{}\PYGZsh{}- No deja espacios en blanco en ambos extremos -\PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}}- \PYG{k}{if} \PYG{k+kp}{true} -\PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}}\PYG{o}{-} \PYG{n+nv}{value} -\PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}}- \PYG{k}{endif} -\PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce 'sin espacios' \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

El ejemplo anterior muestra el modificador de control de espacios en blanco predeterminado, y cómo lo puedes utilizar para quitar los espacios en blanco alrededor de las etiquetas.  Recortar el espacio debe consumir todos los espacios en blanco a ese lado de la etiqueta.  Es posible utilizar el recorte de espacios en blanco en un lado de una etiqueta:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{value} \PYG{o}{=} \PYG{l+s+s1}{'no spaces'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{\textless{}li\textgreater{}    }\PYG{c+cp}{\PYGZob{}\PYGZob{}}\PYG{o}{-} \PYG{n+nv}{value} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{    \textless{}/li\textgreater{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce '\textless{}li\textgreater{}no spaces    \textless{}/li\textgreater{}' \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{Extendiendo}
\label{templates:extendiendo}
Puedes extender \emph{Twig} fácilmente.

Si estás buscando nuevas etiquetas, filtros, o funciones, echa un vistazo al \href{http://github.com/fabpot/Twig-extensions}{repositorio de extensiones oficial de Twig}.

Si deseas crear una propia, lee el capítulo \code{Creando una extensión}.


\part{\emph{Twig} para desarrolladores}
\label{api:twig-para-desarrolladores}\label{api:twig-syntax-mode}\label{api::doc}
Este capítulo describe la \emph{API} para \emph{Twig} y no el lenguaje de plantillas. Será muy útil como referencia para aquellos que implementan la interfaz de plantillas para la aplicación y no para los que están creando plantillas \emph{Twig}.


\chapter{Fundamentos}
\label{api:fundamentos}
\emph{Twig} utiliza un objeto central llamado el \textbf{entorno} (de la clase \code{Twig\_Environment}). Las instancias de esta clase se utilizan para almacenar la configuración y extensiones, y se utilizan para cargar plantillas del sistema de archivos o en otros lugares.

La mayoría de las aplicaciones debe crear un objeto \code{Twig\_Environment} al iniciar la aplicación y usarlo para cargar plantillas. En algunos casos, sin embargo, es útil disponer de múltiples entornos lado a lado, si estás usando distintas configuraciones.

La forma más sencilla de configurar \emph{Twig} para cargar plantillas para tu aplicación se ve más o menos así:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{require\PYGZus{}once} \PYG{l+s+s1}{'/ruta/a/lib/Twig/Autoloader.php'}\PYG{p}{;}
\PYG{n+nx}{Twig\PYGZus{}Autoloader}\PYG{o}{::}\PYG{n+na}{register}\PYG{p}{();}

\PYG{n+nv}{\PYGZdl{}loader} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Loader\PYGZus{}Filesystem}\PYG{p}{(}\PYG{l+s+s1}{'/ruta/a/templates'}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'cache'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'/ruta/a/compilation\PYGZus{}cache'}\PYG{p}{,}
\PYG{p}{));}
\end{Verbatim}

Esto creará un entorno de plantillas con la configuración predeterminada y un cargador que busca las plantillas en el directorio \code{/ruta/a/templates/}. Hay diferentes cargadores disponibles y también puedes escribir el tuyo si deseas cargar plantillas de una base de datos u otros recursos.

\begin{notice}{note}{Nota:}
Ten en cuenta que el segundo argumento del entorno es una matriz de opciones.
La opción \code{cache} es un directorio de caché de compilación, donde \emph{Twig} memoriza las plantillas compiladas para evitar la fase de análisis de las subsiguientes peticiones. Esta es muy diferente de la caché que posiblemente desees agregar para evaluar plantillas. Para tal necesidad, puedes utilizar cualquier biblioteca de caché \emph{PHP} disponible.
\end{notice}

Para cargar una plantilla desde este entorno sólo tienes que llamar al método \code{LoadTemplate()} el cual devuelve una instancia de \code{Twig\_Template}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}template} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{loadTemplate}\PYG{p}{(}\PYG{l+s+s1}{'index.html'}\PYG{p}{);}
\end{Verbatim}

Para reproducir la plantilla con algunas variables, llama al método \code{render()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}template}\PYG{o}{-\textgreater{}}\PYG{n+na}{render}\PYG{p}{(}\PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'the'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'variables'}\PYG{p}{,} \PYG{l+s+s1}{'go'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'here'}\PYG{p}{));}
\end{Verbatim}

\begin{notice}{note}{Nota:}
El método \code{display()} es un atajo para reproducir la plantilla directamente.
\end{notice}

También puedes exponer los métodos de extensión como funciones en tus plantillas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{render}\PYG{p}{(}  \PYG{l+s+s1}{'index.html'}\PYG{p}{,}
                     \PYG{k}{array}\PYG{p}{(} \PYG{l+s+s1}{'the'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'variables'}\PYG{p}{,}
                            \PYG{l+s+s1}{'go'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'here'}
                  \PYG{p}{));}
\end{Verbatim}


\chapter{Opciones del entorno}
\label{api:opciones-del-entorno}\label{api:environment-options}
Al crear una nueva instancia de \code{Twig\_Environment}, puedes pasar una matriz de opciones como segundo argumento del constructor:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'debug'} \PYG{o}{=\textgreater{}} \PYG{k}{true}\PYG{p}{));}
\end{Verbatim}

Las siguientes opciones están disponibles:
\begin{itemize}
\item {} 
\code{debug}: Cuando se establece en \code{true}, las plantillas generadas tienen un método \code{\_\_toString()} que puedes utilizar para mostrar los nodos generados (el predeterminado es \code{false}).

\item {} 
\code{charset}: El juego de caracteres usado por las plantillas (por omisión es \code{utf-8}).

\item {} 
\code{base\_template\_class}: La clase de plantilla base utilizada para generar plantillas (por omisión \code{Twig\_Template}).

\item {} 
\code{cache}: Una ruta absoluta donde almacenar las plantillas compiladas, o \code{false} para desactivar el almacenamiento en caché (el cual es el valor predeterminado).

\item {} 
\code{auto\_reload}: Cuando desarrollas con \emph{Twig}, es útil volver a compilar la plantilla cada vez que el código fuente cambia. Si no proporcionas un valor para la opción \code{auto\_reload}, se determinará automáticamente en función del valor \code{debug}.

\item {} 
\code{strict\_variables}: Si se establece en \code{false}, \emph{Twig} ignorará silenciosamente las variables no válidas (variables y/o atributos/métodos que no existen) y los reemplazará con un valor \code{null}. Cuando se establece en \code{true}, \emph{Twig} produce una excepción en su lugar (el predeterminado es \code{false}).

\item {} 
\code{autoescape}: Si se establece en \code{true}, el escape automático será habilitado de manera predeterminada para todas las plantillas (por omisión a \code{true}). A partir de \emph{Twig 1.8}, puedes implantar la estrategia de escape para usar (\code{html}, \code{js}, \code{false} para desactivarla, o una retrollamada PHP que tome el \code{"nombre de archivo"} de la plantilla y devuelva la estrategia de escape a utilizar).

\item {} 
\code{optimizations}: Una marca que indica cuales optimizaciones aplicar (por omisión a \code{-1} -- todas las optimizaciones están habilitadas; para desactivarla ponla a \code{0}).

\end{itemize}


\chapter{Cargadores}
\label{api:cargadores}
Los cargadores son responsables de cargar las plantillas desde un recurso como el sistema de archivos.


\section{Caché de compilación}
\label{api:cache-de-compilacion}
Todos los cargadores de plantillas en cache pueden compilar plantillas en el sistema de archivos para su futura reutilización. Esto acelera mucho cómo se compilan las plantillas \emph{Twig} una sola vez; y el aumento del rendimiento es aún mayor si utilizas un acelerador \emph{PHP} como \emph{APC}.
Consulta las opciones anteriores \code{cache} y \code{auto\_reload} de \code{Twig\_Environment} para más información.


\section{Cargadores integrados}
\label{api:cargadores-integrados}
Aquí está una lista de los cargadores incorporados de que dispone \emph{Twig}:
\begin{itemize}
\item {} 
\code{Twig\_Loader\_Filesystem}: Carga las plantillas desde el sistema de archivos. Este cargador puede encontrar plantillas en los directorios del sistema de archivos y es la manera preferida de cargarlas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}loader} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Loader\PYGZus{}Filesystem}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}templateDir}\PYG{p}{);}
\end{Verbatim}

También puedes buscar plantillas en una matriz de directorios:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}loader} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Loader\PYGZus{}Filesystem}\PYG{p}{(}
                                       \PYG{k}{array}\PYG{p}{(}  \PYG{n+nv}{\PYGZdl{}templateDir1}\PYG{p}{,}
                                               \PYG{n+nv}{\PYGZdl{}templateDir2}
                                    \PYG{p}{));}
\end{Verbatim}

Con esta configuración, \emph{Twig} buscará primero las plantillas de \code{\$templateDir1} y si no existen, regresará a buscar en \code{\$templateDir2}.

\item {} 
\code{Twig\_Loader\_String}: Carga plantillas desde una cadena. Es un cargador silencioso que va cargando el código fuente directamente a medida que se lo vas pasando:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}loader} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Loader\PYGZus{}String}\PYG{p}{();}
\end{Verbatim}

\item {} 
\code{Twig\_Loader\_Array}: Carga una plantilla desde una matriz \emph{PHP}. Se le pasa una matriz de cadenas vinculadas a los nombres de plantilla. Este cargador es útil para pruebas unitarias:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}loader} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Loader\PYGZus{}Array}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}templates}\PYG{p}{);}
\end{Verbatim}

\end{itemize}

\begin{notice}{tip}{Truco:}
Cuando utilices los cargadores de \code{matriz} o \code{cadena} con un mecanismo de caché, debes saber que se genera una nueva clave de caché cada vez que ``cambia'' el contenido de una plantilla (la clave de caché es el código fuente de la plantilla). Si no deseas ver que tu caché crezca fuera de control, es necesario tener cuidado de limpiar el archivo de caché antiguo en sí mismo.
\end{notice}


\section{Creando tu propio cargador}
\label{api:creando-tu-propio-cargador}
Todos los cargadores implementan la interfaz \code{Twig\_LoaderInterface}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{interface} \PYG{n+nx}{Twig\PYGZus{}LoaderInterface}
\PYG{p}{\PYGZob{}}
    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Obtiene el código fuente de una plantilla, del nombre dado.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @param  string \PYGZdl{}name cadena del nombre de la plantilla a cargar}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return string The template source code}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getSource}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{);}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Obtiene la clave de la caché para usarla en un nombre de plantilla dado.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @param  string \PYGZdl{}name cadena del nombre de la plantilla a cargar}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return string La clave de caché}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getCacheKey}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{);}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve true si la plantilla aún está fresca.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @param string    \PYGZdl{}name El nombre de la plantilla}
\PYG{l+s+sd}{     * @param timestamp \PYGZdl{}time Hora de la última modificación de la plantilla}
\PYG{l+s+sd}{     *                        en caché}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{isFresh}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}time}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

A modo de ejemplo, esto es lo que dice el \code{Twig\_Loader\_String} incorporado:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Twig\PYGZus{}Loader\PYGZus{}String} \PYG{k}{implements} \PYG{n+nx}{Twig\PYGZus{}LoaderInterface}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getSource}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n+nv}{\PYGZdl{}name}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getCacheKey}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n+nv}{\PYGZdl{}name}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{isFresh}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}time}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{k}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

El método \code{isFresh()} debe devolver \code{true} si la plantilla actual en caché aún es fresca, dado el tiempo de la última modificación, o \code{false} de lo contrario.


\chapter{Usando extensiones}
\label{api:usando-extensiones}
Las extensiones \emph{Twig} son paquetes que añaden nuevas características a \emph{Twig}. Usar una extensión es tan simple como usar el método \code{addExtension()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Sandbox}\PYG{p}{());}
\end{Verbatim}

\emph{Twig} viene con las siguientes extensiones:
\begin{itemize}
\item {} 
\emph{Twig\_Extension\_Core}: Define todas las características básicas de \emph{Twig}.

\item {} 
\emph{Twig\_Extension\_Escaper}: Agrega escape automático y la posibilidad de escapar/no escapar bloques de código.

\item {} 
\emph{Twig\_Extension\_Sandbox}: Agrega un modo de recinto de seguridad para el entorno predeterminado de \emph{Twig}, en el cual es seguro evaluar código que no es de confianza.

\item {} 
\emph{Twig\_Extension\_Optimizer}: Optimiza el nodo del árbol antes de la compilación.

\end{itemize}

El núcleo, las extensiones del mecanismo de escape y optimización no es necesario añadirlas al entorno \emph{Twig}, debido a que se registran de forma predeterminada. Puedes desactivar una extensión registrada:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{removeExtension}\PYG{p}{(}\PYG{l+s+s1}{'escaper'}\PYG{p}{);}
\end{Verbatim}


\chapter{Extensiones incorporadas}
\label{api:extensiones-incorporadas}
Esta sección describe las características agregadas por las extensiones incorporadas.

\begin{notice}{tip}{Truco:}
Lee el capítulo sobre la ampliación de \emph{Twig} para que veas cómo crear tus propias extensiones.
\end{notice}


\section{Extensión \texttt{core}}
\label{api:extension-core}
La extensión \code{core} define todas las características principales de \emph{Twig}:
\begin{itemize}
\item {} 
Etiquetas;
\begin{itemize}
\item {} 
\code{for}

\item {} 
\code{if}

\item {} 
\code{extends}

\item {} 
\code{include}

\item {} 
\code{block}

\item {} 
\code{filter}

\item {} 
\code{macro}

\item {} 
\code{import}

\item {} 
\code{from}

\item {} 
\code{set}

\item {} 
\code{spaceless}

\end{itemize}

\item {} 
Filtros:
\begin{itemize}
\item {} 
\code{date}

\item {} 
\code{format}

\item {} 
\code{replace}

\item {} 
\code{url\_encode}

\item {} 
\code{json\_encode}

\item {} 
\code{title}

\item {} 
\code{capitalize}

\item {} 
\code{upper}

\item {} 
\code{lower}

\item {} 
\code{striptags}

\item {} 
\code{join}

\item {} 
\code{reverse}

\item {} 
\code{length}

\item {} 
\code{sort}

\item {} 
\code{merge}

\item {} 
\code{default}

\item {} 
\code{keys}

\item {} 
\code{escape}

\item {} 
\code{e}

\end{itemize}

\item {} 
Funciones:
\begin{itemize}
\item {} 
\code{range}

\item {} 
\code{constant}

\item {} 
\code{cycle}

\item {} 
\code{parent}

\item {} 
\code{block}

\end{itemize}

\item {} 
Pruebas:
\begin{itemize}
\item {} 
\code{even}

\item {} 
\code{odd}

\item {} 
\code{defined}

\item {} 
\code{sameas}

\item {} 
\code{null}

\item {} 
\code{divisibleby}

\item {} 
\code{constant}

\item {} 
\code{empty}

\end{itemize}

\end{itemize}


\section{Extensión \texttt{escaper}}
\label{api:extension-escaper}
La extensión \code{escaper} añade a \emph{Twig} el escape automático de la salida. Esta define una nueva etiqueta, \code{autoescape}, y un filtro \code{raw}.

Al crear la extensión \code{escaper}, puedes activar o desactivar la estrategia de escape global de la salida:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}escaper} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Escaper}\PYG{p}{(}\PYG{k}{true}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}escaper}\PYG{p}{);}
\end{Verbatim}

Si la estableces a \code{true}, se escapan todas las variables en las plantillas, excepto las que utilizan el filtro \code{raw}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{article}\PYG{n+nv}{.to\PYGZus{}html}\PYG{o}{\textbar{}}\PYG{n+nf}{raw} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

También puedes cambiar el modo de escape a nivel local usando la etiqueta \code{autoescape} (consulta la documentación para la sintaxis usada por el {\hyperref[tags/autoescape::doc]{\emph{autoescape}}} (\autopageref*{tags/autoescape::doc}) antes de la versión \emph{1.8} de \emph{Twig}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{l+s+s1}{'html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{raw} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{      }\PYG{c}{\PYGZob{}\PYGZsh{} var no se escapa \PYGZsh{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{escape} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{   }\PYG{c}{\PYGZob{}\PYGZsh{} var no se escapa doblemente \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{warning}{Advertencia:}
La etiqueta \code{autoescape} no tiene ningún efecto sobre los archivos incluidos.
\end{notice}

Las reglas de escape se implementan de la siguiente manera:
\begin{itemize}
\item {} 
Literales (enteros, booleanos, matrices, ...) utilizados en la plantilla directamente como variables o argumentos de filtros no son escapados automáticamente:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"Twig\textless{}br /\textgreater{}"} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} no se escapa \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{text} \PYG{o}{=} \PYG{l+s+s2}{"Twig\textless{}br /\textgreater{}"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{text} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} será escapado \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

\item {} 
Expresiones cuyo resultado siempre es un literal o una variable marcada como segura nunca serán escapadas automáticamente:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZob{} foo ? "Twig\textless{}br /\textgreater{}" : "\textless{}br /\textgreater{}Twig" \PYGZcb{}\PYGZcb{} \PYGZob{}\# no será escapado \#\PYGZcb{}

\PYGZob{}\% set text = "Twig\textless{}br /\textgreater{}" \%\PYGZcb{}
\PYGZob{}\PYGZob{} foo ? text : "\textless{}br /\textgreater{}Twig" \PYGZcb{}\PYGZcb{} \PYGZob{}\# será escapado \#\PYGZcb{}

\PYGZob{}\% set text = "Twig\textless{}br /\textgreater{}" \%\PYGZcb{}
\PYGZob{}\PYGZob{} foo ? text\textbar{}raw : "\textless{}br /\textgreater{}Twig" \PYGZcb{}\PYGZcb{} \PYGZob{}\# no será escapado \#\PYGZcb{}

\PYGZob{}\% set text = "Twig\textless{}br /\textgreater{}" \%\PYGZcb{}
\PYGZob{}\PYGZob{} foo ? text\textbar{}escape : "\textless{}br /\textgreater{}Twig" \PYGZcb{}\PYGZcb{} \PYGZob{}\# el resultado de la expresión
                                          no será escapado \#\PYGZcb{}
\end{Verbatim}

\item {} 
El escape se aplica antes de la impresión, después de haber aplicado cualquier otro filtro:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{upper} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} es equivalente a \PYGZob{}\PYGZob{} var\textbar{}upper\textbar{}escape \PYGZcb{}\PYGZcb{} \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

\item {} 
El filtro \code{raw} sólo se debe utilizar al final de la cadena de filtros:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{raw}\PYG{o}{\textbar{}}\PYG{n+nf}{upper} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} se deberá escapar \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{upper}\PYG{o}{\textbar{}}\PYG{n+nf}{raw} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} no será escapado \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

\item {} 
No se aplica el escape automático si el último filtro de la cadena está marcado como seguro para el contexto actual (por ejemplo, \code{html} o \code{js}). \code{escaper} y \code{escaper('html')} están marcados como seguros para \emph{html}, \code{escaper('js')} está marcado como seguro para \emph{javascript}, \code{raw} está marcado como seguro para todo.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{k+kp}{true} \PYG{n+nv}{js} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{escape}\PYG{o}{(}\PYG{l+s+s1}{'html'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} será escapado para html y javascript \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} será escapado para javascript \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{escape}\PYG{o}{(}\PYG{l+s+s1}{'js'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} no se escapará doblemente \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\end{itemize}

\begin{notice}{note}{Nota:}
Ten en cuenta que el escape automático tiene algunas limitaciones puesto que el escapado se aplica en las expresiones después de su evaluación. Por ejemplo, cuando trabajas en concatenación, \code{\{\{foo\textbar{}raw \textasciitilde{} bar \}\}} no dará el resultado esperado ya que el escape se aplica sobre el resultado de la concatenación y no en las variables individuales (por lo tanto aquí, el filtro \code{raw} no tendrá ningún efecto).
\end{notice}


\section{Extensión \texttt{sandbox}}
\label{api:extension-sandbox}
La extensión \code{sandbox} se puede utilizar para evaluar código no confiable. El acceso a los atributos y los métodos inseguros está prohibido. El entorno recinto de seguridad es manejado por una política de la instancia. Por omisión, \emph{Twig} viene con una política de clase:
\code{Twig\_Sandbox\_SecurityPolicy}. Esta clase te permite agregar a la lista blanca algunas etiquetas, filtros, propiedades y métodos:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}tags} \PYG{o}{=} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'if'}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}filters} \PYG{o}{=} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'upper'}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}methods} \PYG{o}{=} \PYG{k}{array}\PYG{p}{(} \PYG{l+s+s1}{'Article'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}  \PYG{l+s+s1}{'getTitle'}\PYG{p}{,}
                                       \PYG{l+s+s1}{'getBody'}
                                    \PYG{p}{),}
\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}properties} \PYG{o}{=} \PYG{k}{array}\PYG{p}{(} \PYG{l+s+s1}{'Article'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(} \PYG{l+s+s1}{'title'}\PYG{p}{,}
                                         \PYG{l+s+s1}{'body'}
                                       \PYG{p}{),}
\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}functions} \PYG{o}{=} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'range'}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}policy} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Sandbox\PYGZus{}SecurityPolicy}\PYG{p}{(}  \PYG{n+nv}{\PYGZdl{}tags}\PYG{p}{,}
                                            \PYG{n+nv}{\PYGZdl{}filters}\PYG{p}{,}
                                            \PYG{n+nv}{\PYGZdl{}methods}\PYG{p}{,}
                                            \PYG{n+nv}{\PYGZdl{}properties}\PYG{p}{,}
                                            \PYG{n+nv}{\PYGZdl{}functions}
                                          \PYG{p}{);}
\end{Verbatim}

Con la configuración anterior, la política de seguridad sólo te permitirá usar los filtros \code{if}, \code{tag} y \code{upper}. Por otra parte, las plantillas sólo podrán llamar a los métodos \code{getTitle()} y \code{getBody()} en objetos \code{Article}, y a las propiedades públicas \code{title} y \code{body}. Todo lo demás no está permitido y se generará una excepción \code{Twig\_Sandbox\_SecurityError}.

El objeto política es el primer argumento del constructor del recinto de seguridad:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}sandbox} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Sandbox}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}policy}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}sandbox}\PYG{p}{);}
\end{Verbatim}

De forma predeterminada, el modo de recinto de seguridad está desactivado y se activa cuando se incluye código de plantilla que no es de confianza usando la etiqueta \code{sandbox}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{sandbox} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'user.html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endsandbox} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Puedes poner todas las plantillas en el recinto de seguridad pasando \code{true} como segundo argumento al constructor de la extensión:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}sandbox} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Sandbox}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}policy}\PYG{p}{,} \PYG{k}{true}\PYG{p}{);}
\end{Verbatim}


\section{Extensión \texttt{optimizer}}
\label{api:extension-optimizer}
La extensión \code{optimizer} optimiza el nodo del árbol antes de compilarlo:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Optimizer}\PYG{p}{());}
\end{Verbatim}

Por omisión, todas las optimizaciones están activadas. Puedes seleccionar las que desees habilitar pasándolas al constructor:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}optimizer} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Optimizer}\PYG{p}{(}
                                \PYG{n+nx}{Twig\PYGZus{}NodeVisitor\PYGZus{}Optimizer}\PYG{o}{::}\PYG{n+na}{OPTIMIZE\PYGZus{}FOR}\PYG{p}{);}

\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}optimizer}\PYG{p}{);}
\end{Verbatim}


\chapter{Excepciones}
\label{api:excepciones}
\emph{Twig} puede lanzar excepciones:
\begin{itemize}
\item {} 
\code{Twig\_Error}: La excepción base para todos los errores.

\item {} 
\code{Twig\_Error\_Syntax}: Lanzada para indicar al usuario que hay un problema con la sintaxis de la plantilla.

\item {} 
\code{Twig\_Error\_Runtime}: Lanzada cuando se produce un error en tiempo de ejecución (cuando un filtro no existe, por ejemplo).

\item {} 
\code{Twig\_Error\_Loader}: Se lanza al producirse un error durante la carga de la plantilla.

\item {} 
\code{Twig\_Sandbox\_SecurityError}: Lanzada cuando aparece una etiqueta, filtro, o se llama a un método no permitido en una plantilla de un recinto de seguridad.

\end{itemize}


\part{Extendiendo \emph{Twig}}
\label{advanced::doc}\label{advanced:extendiendo-twig}
\emph{Twig} se puede extender en muchos aspectos; puedes añadir etiquetas adicionales, filtros, pruebas, operadores, variables globales y funciones. Incluso puedes extender el propio analizador con visitantes de nodo.

\begin{notice}{note}{Nota:}
Este capítulo describe cómo extender \emph{Twig} fácilmente. Si deseas reutilizar tus cambios en diferentes proyectos o si quieres compartirlos con los demás, entonces, debes crear una extensión tal como se describe en el siguiente capítulo.
\end{notice}

Antes de extender \emph{Twig}, debes entender las diferencias entre todos los diferentes puntos de extensión posibles y cuándo utilizarlos.

En primer lugar, recuerda que el lenguaje de \emph{Twig} tiene dos construcciones principales:
\begin{itemize}
\item {} 
\code{\{\{ \}\}}: Utilizada para imprimir el resultado de la evaluación de la expresión;

\item {} 
\code{\{\% \%\}}: Utilizada para ejecutar declaraciones.

\end{itemize}

Para entender por qué \emph{Twig} expone tantos puntos de extensión, vamos a ver cómo implementar un generador \emph{Lorem ipsum} (este necesita saber el número de palabras a generar).

Puedes utilizar una \emph{etiqueta} \code{Lipsum}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{lipsum} \PYG{l+m}{4}\PYG{l+m}{0} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Eso funciona, pero usar una etiqueta para \code{lipsum} no es una buena idea por al menos tres razones principales:
\begin{itemize}
\item {} 
\code{lipsum} no es una construcción del lenguaje;

\item {} 
La etiqueta produce algo;

\item {} 
La etiqueta no es flexible ya que no la puedes utilizar en una expresión:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZob{} 'algún texto' \textasciitilde{} \PYGZob{}\% lipsum 40 \%\PYGZcb{} \textasciitilde{} 'algo más de texto' \PYGZcb{}\PYGZcb{}
\end{Verbatim}

\end{itemize}

De hecho, rara vez es necesario crear etiquetas; y es una muy buena noticia porque las etiquetas son el punto de extensión más complejo de \emph{Twig}.

Ahora, vamos a utilizar un \emph{filtro} \code{lipsum}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+m}{4}\PYG{l+m}{0}\PYG{o}{\textbar{}}\PYG{n+nf}{lipsum} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Una vez más, funciona, pero se ve raro. Un filtro transforma el valor que se le pasa a alguna otra cosa, pero aquí utilizamos el valor para indicar el número de palabras a generar.

En seguida, vamos a utilizar una \emph{función} \code{lipsum}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{lipsum}\PYG{o}{(}\PYG{l+m}{4}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Aquí vamos. Para este ejemplo concreto, la creación de una función es el punto de extensión a usar. Y la puedes usar en cualquier lugar en que se acepte una expresión:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'algún texto'} \PYG{o}{\PYGZti{}} \PYG{n+nv}{lipsum}\PYG{o}{(}\PYG{l+m}{4}\PYG{l+m}{0}\PYG{o}{)} \PYG{o}{\PYGZti{}} \PYG{l+s+s1}{'algo más de texto'} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{lipsum} \PYG{o}{=} \PYG{n+nv}{lipsum}\PYG{o}{(}\PYG{l+m}{4}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Por último pero no menos importante, también puedes utilizar un objeto \emph{global} con un método capaz de generar texto \emph{Lorem Ipsum}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{text}\PYG{n+nv}{.lipsum}\PYG{o}{(}\PYG{l+m}{4}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Como regla general, utiliza funciones para las características más utilizadas y objetos globales para todo lo demás.

Ten en cuenta lo siguiente cuando quieras extender \emph{Twig}:

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{
¿Qué?
} & \textbf{
¿dificultad para implementarlo?
} & \textbf{
¿Con qué frecuencia?
} & \textbf{
¿Cuándo?
}\\\hline

\emph{macro}
 & 
trivial
 & 
frecuente
 & 
Generación de contenido
\\\hline

\emph{global}
 & 
trivial
 & 
frecuente
 & 
Objeto ayudante
\\\hline

\emph{function}
 & 
trivial
 & 
frecuente
 & 
Generación de contenido
\\\hline

\emph{filter}
 & 
trivial
 & 
frecuente
 & 
Transformación de valor
\\\hline

\emph{tag}
 & 
complejo
 & 
raro
 & 
Constructor del lenguaje \emph{DSL}
\\\hline

\emph{test}
 & 
trivial
 & 
raro
 & 
Decisión booleana
\\\hline

\emph{operator}
 & 
trivial
 & 
raro
 & 
Transformación de valores
\\\hline
\end{tabulary}



\chapter{Globales}
\label{advanced:globales}
Una variable global es como cualquier otra variable de plantilla, excepto que está disponible en todas las plantillas y macros:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addGlobal}\PYG{p}{(}\PYG{l+s+s1}{'text'}\PYG{p}{,} \PYG{k}{new} \PYG{n+nx}{Text}\PYG{p}{());}
\end{Verbatim}

Entonces puedes utilizar la variable \code{text} en cualquier parte de una plantilla:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{text}\PYG{n+nv}{.lipsum}\PYG{o}{(}\PYG{l+m}{4}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}


\chapter{Filtros}
\label{advanced:filtros}
Un filtro es una función \emph{PHP} regular o un método de objeto que toma el lado izquierdo del filtro (antes del tubo \code{\textbar{}}) como primer argumento y los argumentos adicionales pasados ​​al filtro (entre paréntesis \code{()}) como argumentos adicionales.

La definición de un filtro es tan fácil como asociar el nombre del filtro con un ejecutable de \emph{PHP}. Por ejemplo, digamos que tienes el siguiente código en una plantilla:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'TWIG'}\PYG{o}{\textbar{}}\PYG{n+nf}{lower} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Al compilar esta plantilla para \emph{PHP}, \emph{Twig} busca el ejecutable \emph{PHP} asociado con el filtro \code{lower}. El filtro \code{lower} es un filtro integrado en \emph{Twig}, y simplemente se asigna a la función \emph{PHP} \code{strtolower()}. Después de la compilación, el código generado por \emph{PHP} es más o menos equivalente a:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php} \PYG{k}{echo} \PYG{n+nb}{strtolower}\PYG{p}{(}\PYG{l+s+s1}{'TWIG'}\PYG{p}{)} \PYG{c+cp}{?\textgreater{}}
\end{Verbatim}

Como puedes ver, la cadena \code{'TWIG'} se pasa como primer argumento a la función de \emph{PHP}.

Un filtro también puede tomar argumentos adicionales como en el siguiente ejemplo:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{now}\PYG{o}{\textbar{}}\PYG{n+nf}{date}\PYG{o}{(}\PYG{l+s+s1}{'d/m/Y'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

En este caso, los argumentos adicionales son pasados​ a la función después del argumento principal, y el código compilado es equivalente a:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php} \PYG{k}{echo} \PYG{n+nx}{twig\PYGZus{}date\PYGZus{}format\PYGZus{}filter}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}now}\PYG{p}{,} \PYG{l+s+s1}{'d/m/Y'}\PYG{p}{)} \PYG{c+cp}{?\textgreater{}}
\end{Verbatim}

Vamos a ver cómo crear un nuevo filtro.

En esta sección, vamos a crear un filtro \code{rot13}, el cual debe devolver la transformación \href{http://www.php.net/manual/en/function.str-rot13.php}{rot13} de una cadena. Aquí está un ejemplo de su uso y los resultados esperados:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"Twig"}\PYG{o}{\textbar{}}\PYG{n+nf}{rot13} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} debería mostrar Gjvt \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Agregar un filtro es tan sencillo como llamar al método \code{addFilter()} en la instancia de \code{Twig\_Environment}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFilter}\PYG{p}{(}\PYG{l+s+s1}{'rot13'}\PYG{p}{,} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'str\PYGZus{}rot13'}\PYG{p}{));}
\end{Verbatim}

El segundo argumento de \code{addFilter()} es una instancia de \code{Twig\_Filter}.
Aquí, utilizamos \code{Twig\_Filter\_Function} puesto que el filtro es una función \emph{PHP}. El primer argumento pasado al constructor \code{Twig\_Filter\_Function} es el nombre de la función \emph{PHP} a llamar, aquí \code{str\_rot13}, una función nativa de \emph{PHP}.

Digamos que ahora deseas poder añadir un prefijo antes de la cadena convertida:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"Twig"}\PYG{o}{\textbar{}}\PYG{n+nf}{rot13}\PYG{o}{(}\PYG{l+s+s1}{'prefijo\PYGZus{}'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} debe mostrar prefijo\PYGZus{}Gjvt \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Como la función \code{str\_rot13()} de \emph{PHP} no es compatible con este requisito, vamos a crear una nueva función \emph{PHP}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{function} \PYG{n+nf}{project\PYGZus{}compute\PYGZus{}rot13}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}string}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}prefix} \PYG{o}{=} \PYG{l+s+s1}{''}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n+nv}{\PYGZdl{}prefix}\PYG{o}{.}\PYG{n+nb}{str\PYGZus{}rot13}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}string}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Como puedes ver, el argumento \code{prefix} del filtro se pasa como un argumento adicional a la función \code{project\_compute\_rot13()}.

La adición de este filtro es tan fácil como antes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFilter}\PYG{p}{(} \PYG{l+s+s1}{'rot13'}\PYG{p}{,}
                  \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'project\PYGZus{}compute\PYGZus{}rot13'}
                \PYG{p}{));}
\end{Verbatim}

Para una mejor encapsulación, también puedes definir un filtro como un método estático de una clase. También puedes utilizar la clase \code{Twig\_Filter\_Function} para registrar métodos estáticos, tal como filtros:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFilter}\PYG{p}{(} \PYG{l+s+s1}{'rot13'}\PYG{p}{,}
                  \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'SomeClass::rot13Filter'}
                \PYG{p}{));}
\end{Verbatim}

\begin{notice}{tip}{Truco:}
En una extensión, también puedes definir un filtro como un método estático de la clase extendida.
\end{notice}


\section{Entorno consciente de filtros}
\label{advanced:entorno-consciente-de-filtros}
La clase \code{Twig\_Filter} toma opciones como su último argumento. Por ejemplo, si deseas acceder a la instancia del entorno actual en tu filtro, establece la opción \code{needs\_environment} a \code{true}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}filter} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}  \PYG{l+s+s1}{'str\PYGZus{}rot13'}\PYG{p}{,}
                                     \PYG{k}{array}\PYG{p}{(}  \PYG{l+s+s1}{'needs\PYGZus{}environment'} \PYG{o}{=\textgreater{}} \PYG{k}{true}
                                  \PYG{p}{));}
\end{Verbatim}

\emph{Twig} entonces pasará el entorno actual como primer argumento al invocar el filtro:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{function} \PYG{n+nf}{twig\PYGZus{}compute\PYGZus{}rot13}\PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Environment} \PYG{n+nv}{\PYGZdl{}env}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}string}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// obtiene el juego de caracteres actual, por ejemplo}
    \PYG{n+nv}{\PYGZdl{}charset} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}env}\PYG{o}{-\textgreater{}}\PYG{n+na}{getCharset}\PYG{p}{();}

    \PYG{k}{return} \PYG{n+nb}{str\PYGZus{}rot13}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}string}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{Escapando automáticamente}
\label{advanced:escapando-automaticamente}
Si está habilitado el escape automático, puedes escapar la salida del filtro antes de imprimir. Si tu filtro actúa como un escapista (o explícitamente produce código \emph{html} o \emph{javascript}), desearás que se imprima la salida cruda. En tal caso, establece la opción \code{is\_safe}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}filter} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}  \PYG{l+s+s1}{'nl2br'}\PYG{p}{,}
                                     \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'is\PYGZus{}safe'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'html'}\PYG{p}{)}
                                  \PYG{p}{));}
\end{Verbatim}

Algunos filtros posiblemente tengan que trabajar en valores ya escapados o seguros. En tal caso, establece la opción \code{pre\_escape}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}filter} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}  \PYG{l+s+s1}{'somefilter'}\PYG{p}{,}
                                     \PYG{k}{array}\PYG{p}{(} \PYG{l+s+s1}{'pre\PYGZus{}escape'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'html'}\PYG{p}{,}
                                            \PYG{l+s+s1}{'is\PYGZus{}safe'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'html'}\PYG{p}{)}
                                  \PYG{p}{));}
\end{Verbatim}


\section{Filtros dinámicos}
\label{advanced:filtros-dinamicos}Nuevo en la versión 1.5: El apoyo a los filtros dinámicos se añadió en \emph{Twig} 1.5.
Un nombre de filtro que contiene el carácter especial \code{*} es un filtro dinámico debido a que el \code{*} puede ser cualquier cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFilter}\PYG{p}{(}\PYG{l+s+s1}{'*\PYGZus{}path'}\PYG{p}{,} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'twig\PYGZus{}path'}\PYG{p}{));}

\PYG{k}{function} \PYG{n+nf}{twig\PYGZus{}path}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}arguments}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Los siguientes filtros deben corresponder con el filtro dinámico definido anteriormente:
\begin{itemize}
\item {} 
\code{product\_path}

\item {} 
\code{category\_path}

\end{itemize}

Un filtro dinámico puede definir más de una parte dinámica:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFilter}\PYG{p}{(}\PYG{l+s+s1}{'*\PYGZus{}path\PYGZus{}*'}\PYG{p}{,} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'twig\PYGZus{}path'}\PYG{p}{));}

\PYG{k}{function} \PYG{n+nf}{twig\PYGZus{}path}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}suffix}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}arguments}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

El filtro debe recibir todos los valores de las partes dinámicas antes de los argumentos normales de los filtros. Por ejemplo, una llamada a \code{'foo'\textbar{}a\_path\_b()} resultará en la siguiente llamada \emph{PHP}: \code{twig\_path('a', 'b', 'foo')}.


\chapter{Funciones}
\label{advanced:funciones}
Una función es una función \emph{PHP} regular o un método de objeto que puedes llamar desde las plantillas.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{constant}\PYG{o}{(}\PYG{l+s+s2}{"DATE\PYGZus{}W3C"}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Al compilar esta plantilla para \emph{PHP}, \emph{Twig} busca el \emph{PHP} ejecutable asociado con la función \code{constant}. La función \code{constant} está integrada en las funciones \emph{Twig}, asignada simplemente a la función \code{constant()} de \emph{PHP}. Después de la compilación, el código generado por \emph{PHP} es más o menos equivalente a:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}?php} \PYG{k}{echo} \PYG{n+nb}{constant}\PYG{p}{(}\PYG{l+s+s1}{'DATE\PYGZus{}W3C'}\PYG{p}{)} \PYG{c+cp}{?\textgreater{}}
\end{Verbatim}

Agregar una función es similar a agregar un filtro. Esto se puede hacer llamando al método \code{addFunction()} en la instancia de \code{Twig\_Environment}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFunction}\PYG{p}{(}\PYG{l+s+s1}{'functionName'}\PYG{p}{,} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Function\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'someFunction'}\PYG{p}{));}
\end{Verbatim}

También puedes exponer los métodos de extensión como funciones en tus plantillas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// \PYGZdl{}this es un objeto que implementa a Twig\PYGZus{}ExtensionInterface.}
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFunction}\PYG{p}{(}\PYG{l+s+s1}{'otherFunction'}\PYG{p}{,} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Function\PYGZus{}Method}\PYG{p}{(}  \PYG{n+nv}{\PYGZdl{}this}\PYG{p}{,}
                                                               \PYG{l+s+s1}{'someMethod'}
                                                            \PYG{p}{));}
\end{Verbatim}

Las funciones también son compatibles con los parámetros \code{needs\_environment} e \code{is\_safe}.


\section{Funciones dinámicas}
\label{advanced:funciones-dinamicas}Nuevo en la versión 1.5: La compatibilidad con las funciones dinámicas se añadió en \emph{Twig} 1.5.
Un nombre de función que contiene el carácter especial \code{*} es una función dinámica debido a que el \code{*} puede ser cualquier cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFunction}\PYG{p}{(}\PYG{l+s+s1}{'*\PYGZus{}path'}\PYG{p}{,} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Function\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'twig\PYGZus{}path'}\PYG{p}{));}

\PYG{k}{function} \PYG{n+nf}{twig\PYGZus{}path}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}arguments}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Las siguientes funciones deben corresponder con la función dinámica definida anteriormente:
\begin{itemize}
\item {} 
\code{product\_path}

\item {} 
\code{category\_path}

\end{itemize}

Una función dinámica puede definir más de una parte dinámica:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFilter}\PYG{p}{(}\PYG{l+s+s1}{'*\PYGZus{}path\PYGZus{}*'}\PYG{p}{,} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'twig\PYGZus{}path'}\PYG{p}{));}

\PYG{k}{function} \PYG{n+nf}{twig\PYGZus{}path}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}suffix}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}arguments}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

La función debe recibir todos los valores de las partes dinámicas antes de los argumentos normales de las funciones. Por ejemplo, una llamada a \code{a\_path\_b('foo')} resultará en la siguiente llamada \emph{PHP}: \code{twig\_path('a', 'b', 'foo')}.


\chapter{Etiquetas}
\label{advanced:etiquetas}
Una de las características más interesantes de un motor de plantillas como \emph{Twig} es la posibilidad de definir nuevas construcciones del lenguaje. Esta también es la característica más compleja que necesitas comprender de cómo trabaja \emph{Twig} internamente.

Vamos a crear una simple etiqueta \code{set} que te permita definir variables simples dentro de una plantilla. Puedes utilizar la etiqueta de la siguiente manera:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{name} \PYG{o}{=} \PYG{l+s+s2}{"value"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{name} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} debe producir value \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
La etiqueta \code{set} es parte de la extensión \code{core} y como tal siempre está disponible. La versión integrada es un poco más potente y de manera predeterminada es compatible con múltiples asignaciones (consulta el capítulo {\hyperref[templates::doc]{\emph{Twig para diseñadores de plantillas}}} (\autopageref*{templates::doc}) para más información).
\end{notice}

para definir una nueva etiqueta son necesarios tres pasos:
\begin{itemize}
\item {} 
Definir una clase para analizar segmentos (responsable de analizar el código de la plantilla);

\item {} 
Definir una clase Nodo (responsable de convertir el código analizado a \emph{PHP});

\item {} 
Registrar la etiqueta.

\end{itemize}


\section{Registrando una nueva etiqueta}
\label{advanced:registrando-una-nueva-etiqueta}
Agregar una etiqueta es tan simple como una llamada al método \code{addTokenParser} en la instancia de \code{Twig\_Environment}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addTokenParser}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{Project\PYGZus{}Set\PYGZus{}TokenParser}\PYG{p}{());}
\end{Verbatim}


\section{Definiendo un analizador de fragmentos}
\label{advanced:definiendo-un-analizador-de-fragmentos}
Ahora, vamos a ver el código real de esta clase:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Set\PYGZus{}TokenParser} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}TokenParser}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{parse}\PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Token} \PYG{n+nv}{\PYGZdl{}token}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n+nv}{\PYGZdl{}lineno} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}token}\PYG{o}{-\textgreater{}}\PYG{n+na}{getLine}\PYG{p}{();}
        \PYG{n+nv}{\PYGZdl{}name} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{parser}
                      \PYG{o}{-\textgreater{}}\PYG{n+na}{getStream}\PYG{p}{()}
                      \PYG{o}{-\textgreater{}}\PYG{n+na}{expect}\PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Token}\PYG{o}{::}\PYG{n+na}{NAME\PYGZus{}TYPE}\PYG{p}{)}
                      \PYG{o}{-\textgreater{}}\PYG{n+na}{getValue}\PYG{p}{();}
        \PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{parser}\PYG{o}{-\textgreater{}}\PYG{n+na}{getExpressionParser}\PYG{p}{()}
                     \PYG{o}{-\textgreater{}}\PYG{n+na}{expect}\PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Token}\PYG{o}{::}\PYG{n+na}{OPERATOR\PYGZus{}TYPE}\PYG{p}{,} \PYG{l+s+s1}{'='}\PYG{p}{);}
        \PYG{n+nv}{\PYGZdl{}value} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{parser}
                      \PYG{o}{-\textgreater{}}\PYG{n+na}{getExpressionParser}\PYG{p}{()}
                      \PYG{o}{-\textgreater{}}\PYG{n+na}{parseExpression}\PYG{p}{();}

        \PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{parser}\PYG{o}{-\textgreater{}}\PYG{n+na}{getStream}\PYG{p}{()}
                     \PYG{o}{-\textgreater{}}\PYG{n+na}{expect}\PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Token}\PYG{o}{::}\PYG{n+na}{BLOCK\PYGZus{}END\PYGZus{}TYPE}\PYG{p}{);}

        \PYG{k}{return} \PYG{k}{new} \PYG{n+nx}{Project\PYGZus{}Set\PYGZus{}Node}\PYG{p}{(}  \PYG{n+nv}{\PYGZdl{}name}\PYG{p}{,}
                                      \PYG{n+nv}{\PYGZdl{}value}\PYG{p}{,}
                                      \PYG{n+nv}{\PYGZdl{}lineno}\PYG{p}{,}
                                      \PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{getTag}\PYG{p}{()}
                                   \PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getTag}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+s+s1}{'set'}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

El método \code{getTag()} debe devolver la etiqueta que queremos analizar, aquí \code{set}.

El método \code{parse()} se invoca cada vez que el analizador encuentra una etiqueta \code{set}. Este debe devolver una instancia de \code{Twig\_Node} que representa el nodo (la llamada para la creación del \code{Project\_Set\_Node} se explica en la siguiente sección).

El proceso de análisis se simplifica gracias a un montón de métodos que se pueden llamar desde el fragmento del flujo (\code{\$this-\textgreater{}parser-\textgreater{}getStream()}):
\begin{itemize}
\item {} 
\code{getCurrent()}: Obtiene el segmento actual del flujo.

\item {} 
\code{next()}: Mueve al siguiente segmento en la secuencia, \emph{pero devuelve el antiguo}.

\item {} 
\code{test(\$type)}, \code{test(\$value)} o \code{test(\$type, \$value)}: Determina si el segmento actual es de un tipo o valor particular (o ambos). El valor puede ser una matriz de varios posibles valores.

\item {} 
\code{expect(\$type{[}, \$value{[}, \$message{]}{]})}: Si el segmento actual no es del tipo/valor dado lanza un error de sintaxis. De lo contrario, si el tipo y valor son correctos, devuelve el segmento y mueve el flujo al siguiente segmento.

\item {} 
\code{look()}: Busca el siguiente segmento sin consumirlo.

\end{itemize}

Las expresiones de análisis se llevan a cabo llamando a \code{parseExpression()} como lo hicimos para la etiqueta \code{set}.

\begin{notice}{tip}{Truco:}
Leer las clases \code{TokenParser} existentes es la mejor manera de aprender todos los detalles esenciales del proceso de análisis.
\end{notice}


\section{Definiendo un nodo}
\label{advanced:definiendo-un-nodo}
La clase \code{Project\_Set\_Node} en sí misma es bastante simple:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Set\PYGZus{}Node} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Node}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{\PYGZus{}\PYGZus{}construct}\PYG{p}{(}  \PYG{n+nv}{\PYGZdl{}name}\PYG{p}{,}
                                  \PYG{n+nx}{Twig\PYGZus{}Node\PYGZus{}Expression} \PYG{n+nv}{\PYGZdl{}value}\PYG{p}{,}
                                  \PYG{n+nv}{\PYGZdl{}lineno}\PYG{p}{,}
                                  \PYG{n+nv}{\PYGZdl{}tag} \PYG{o}{=} \PYG{k}{null}
                               \PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{parent}\PYG{o}{::}\PYG{n+na}{\PYGZus{}\PYGZus{}construct}\PYG{p}{(}  \PYG{k}{array}\PYG{p}{(} \PYG{l+s+s1}{'value'} \PYG{o}{=\textgreater{}} \PYG{n+nv}{\PYGZdl{}value} \PYG{p}{),}
                              \PYG{k}{array}\PYG{p}{(} \PYG{l+s+s1}{'name'}  \PYG{o}{=\textgreater{}} \PYG{n+nv}{\PYGZdl{}name}  \PYG{p}{),}
                              \PYG{n+nv}{\PYGZdl{}lineno}\PYG{p}{,}
                              \PYG{n+nv}{\PYGZdl{}tag}
                           \PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{compile}\PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Compiler} \PYG{n+nv}{\PYGZdl{}compiler}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n+nv}{\PYGZdl{}compiler}
            \PYG{o}{-\textgreater{}}\PYG{n+na}{addDebugInfo}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}this}\PYG{p}{)}
            \PYG{o}{-\textgreater{}}\PYG{n+na}{write}\PYG{p}{(}\PYG{l+s+s1}{'\PYGZdl{}context[\PYGZbs{}''}\PYG{o}{.}\PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{getAttribute}\PYG{p}{(}\PYG{l+s+s1}{'name'}\PYG{p}{)}\PYG{o}{.}\PYG{l+s+s1}{'\PYGZbs{}'] = '}\PYG{p}{)}
            \PYG{o}{-\textgreater{}}\PYG{n+na}{subcompile}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{getNode}\PYG{p}{(}\PYG{l+s+s1}{'value'}\PYG{p}{))}
            \PYG{o}{-\textgreater{}}\PYG{n+na}{raw}\PYG{p}{(}\PYG{l+s+s2}{"}\PYG{l+s+s2}{;}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{"}\PYG{p}{)}
        \PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

El compilador implementa una interfaz fluida y proporciona métodos que ayudan a los desarrolladores a generar código \emph{PHP} hermoso y fácil de leer:
\begin{itemize}
\item {} 
\code{subcompile()}: Compila un nodo.

\item {} 
\code{raw()}: Escribe la cadena dada tal cual.

\item {} 
\code{write()}: Escribe la cadena dada añadiendo sangría al principio de cada línea.

\item {} 
\code{string()}: Escribe una cadena entre comillas.

\item {} 
\code{repr()}: Escribe una representación \emph{PHP} de un valor dado (consulta \code{Twig\_Node\_For} para un ejemplo real).

\item {} 
\code{addDebugInfo()}: Agrega como comentario la línea del archivo de plantilla original relacionado con el nodo actual.

\item {} 
\code{indent()}: Aplica sangrías el código generado (consulta \code{Twig\_Node\_Block} para un ejemplo real).

\item {} 
\code{outdent()}: Quita la sangría el código generado (consulta \code{Twig\_Node\_Block} para un ejemplo real).

\end{itemize}


\chapter{Creando una extensión}
\label{advanced:creando-una-extension}\label{advanced:creating-extensions}
La principal motivación para escribir una extensión es mover el código usado frecuentemente a una clase reutilizable como agregar apoyo para la internacionalización. Una extensión puede definir etiquetas, filtros, pruebas, operadores, variables globales, funciones y visitantes de nodo.

La creación de una extensión también hace una mejor separación del código que se ejecuta en tiempo de compilación y el código necesario en tiempo de ejecución. Por lo tanto, hace que tu código sea más rápido.

La mayoría de las veces, es útil crear una extensión para tu proyecto, para acoger todas las etiquetas y filtros específicos que deseas agregar a \emph{Twig}.

\begin{notice}{note}{Nota:}
Antes de escribir tus propias extensiones, echa un vistazo al repositorio de extensiones oficial de \emph{Twig}: \href{http://github.com/fabpot/Twig-extensions}{http://github.com/fabpot/Twig-extensions}.
\end{notice}

Una extensión es una clase que implementa la siguiente interfaz:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{interface} \PYG{n+nx}{Twig\PYGZus{}ExtensionInterface}
\PYG{p}{\PYGZob{}}
    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Inicia el entorno en tiempo de ejecución.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * Aquí es donde puedes cargar algún archivo que contenga funciones}
\PYG{l+s+sd}{     * de filtro, por ejemplo.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @param Twig\PYGZus{}Environment \PYGZdl{}environment La instancia actual de}
\PYG{l+s+sd}{     *                                      Twig\PYGZus{}Environment}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{initRuntime}\PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Environment} \PYG{n+nv}{\PYGZdl{}environment}\PYG{p}{);}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve instancias del analizador de segmentos para añadirlos a}
\PYG{l+s+sd}{     * la lista existente.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return array Un arreglo de instancias Twig\PYGZus{}TokenParserInterface}
\PYG{l+s+sd}{     *               o Twig\PYGZus{}TokenParserBrokerInterface}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getTokenParsers}\PYG{p}{();}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve instancias del visitante de nodos para añadirlas a la}
\PYG{l+s+sd}{     * lista existente.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return array Un arreglo de instancias de}
\PYG{l+s+sd}{     *                Twig\PYGZus{}NodeVisitorInterface}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getNodeVisitors}\PYG{p}{();}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve una lista de filtros para añadirla a la lista}
\PYG{l+s+sd}{     * existente.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return array Un arreglo de filtros}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getFilters}\PYG{p}{();}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve una lista de pruebas para añadirla a la lista}
\PYG{l+s+sd}{     *  existente.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return array Un arreglo de pruebas}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getTests}\PYG{p}{();}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve una lista de funciones para añadirla a la lista}
\PYG{l+s+sd}{     * existente.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return array Un arreglo de funciones}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getFunctions}\PYG{p}{();}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve una lista de operadores para añadirla a la lista}
\PYG{l+s+sd}{     * existente.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return array Un arreglo de operadores}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getOperators}\PYG{p}{();}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve una lista de variables globales para añadirla a la}
\PYG{l+s+sd}{     * lista existente.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return array Un arreglo de variables globales}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getGlobals}\PYG{p}{();}

    \PYG{l+s+sd}{/**}
\PYG{l+s+sd}{     * Devuelve el nombre de la extensión.}
\PYG{l+s+sd}{     *}
\PYG{l+s+sd}{     * @return string El nombre de la extensión}
\PYG{l+s+sd}{     */}
    \PYG{k}{function} \PYG{n+nf}{getName}\PYG{p}{();}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Para mantener tu clase de extensión limpia y ordenada, puedes heredar de la clase \code{Twig\_Extension} incorporada en lugar de implementar toda la interfaz. De esta forma, sólo tienes que implementar el método \code{getName()} como el que proporcionan las implementaciones vacías de \code{Twig\_Extension} para todos los otros métodos.

El método \code{getName()} debe devolver un identificador único para tu extensión.

Ahora, con esta información en mente, vamos a crear la extensión más básica posible:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Twig\PYGZus{}Extension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getName}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+s+s1}{'project'}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Por supuesto, esta extensión no hace nada por ahora. Vamos a personalizarla en las siguientes secciones.
\end{notice}

A \emph{Twig} no le importa dónde guardas tu extensión en el sistema de archivos, puesto que todas las extensiones se deben registrar explícitamente para estar disponibles en tus plantillas.

Puedes registrar una extensión con el método \code{addExtension()} en tu objeto \code{Environment} principal:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{Project\PYGZus{}Twig\PYGZus{}Extension}\PYG{p}{());}
\end{Verbatim}

Por supuesto, tienes que cargar primero el archivo de la extensión, ya sea utilizando \code{require\_once()} o con un cargador automático (consulta la sección \href{http://www.php.net/spl\_autoload\_register}{spl\_autoload\_register()}).

\begin{notice}{tip}{Truco:}
Las extensiones integradas son grandes ejemplos de cómo trabajan las extensiones.
\end{notice}


\section{Globales}
\label{advanced:id1}
Puedes registrar las variables globales en una extensión vía el método \code{getGlobals()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Twig\PYGZus{}Extension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getGlobals}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{array}\PYG{p}{(}
            \PYG{l+s+s1}{'text'} \PYG{o}{=\textgreater{}} \PYG{k}{new} \PYG{n+nx}{Text}\PYG{p}{(),}
        \PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{Funciones}
\label{advanced:id2}
Puedes registrar funciones en una extensión vía el método \code{getFunctions()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Twig\PYGZus{}Extension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getFunctions}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{array}\PYG{p}{(}
            \PYG{l+s+s1}{'lipsum'} \PYG{o}{=\textgreater{}} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Function\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'generate\PYGZus{}lipsum'}\PYG{p}{),}
        \PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{Filtros}
\label{advanced:id3}
Para agregar un filtro a una extensión, es necesario sustituir el método \code{getFilters()}. Este método debe devolver una matriz de filtros para añadir al entorno \emph{Twig}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Twig\PYGZus{}Extension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getFilters}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{array}\PYG{p}{(}
            \PYG{l+s+s1}{'rot13'} \PYG{o}{=\textgreater{}} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'str\PYGZus{}rot13'}\PYG{p}{),}
        \PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Como puedes ver en el código anterior, el método \code{getFilters()} devuelve una matriz donde las claves son el nombre de los filtros (\code{rot13}) y los valores de la definición del filtro (\code{new Twig\_Filter\_Function('str\_rot13')}).

Como vimos en el capítulo anterior, también puedes definir filtros como métodos estáticos en la clase de la extensión:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addFilter}\PYG{p}{(}  \PYG{l+s+s1}{'rot13'}\PYG{p}{,}
                   \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Function}\PYG{p}{(}
                           \PYG{l+s+s1}{'Project\PYGZus{}Twig\PYGZus{}Extension::rot13Filter'}
                                            \PYG{p}{)}
                \PYG{p}{);}
\end{Verbatim}

También puedes utilizar \code{Twig\_Filter\_Method} en lugar de \code{Twig\_Filter\_Function} cuando definas un filtro que usa un método:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Twig\PYGZus{}Extension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getFilters}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{array}\PYG{p}{(}
            \PYG{l+s+s1}{'rot13'} \PYG{o}{=\textgreater{}} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Method}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}this}\PYG{p}{,} \PYG{l+s+s1}{'rot13Filter'}\PYG{p}{),}
        \PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{rot13Filter}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}string}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{str\PYGZus{}rot13}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}string}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

El primer argumento del constructor de \code{Twig\_Filter\_Method} siempre es \code{\$this}, el objeto extensión actual. El segundo es el nombre del método a llamar.

Usar métodos de filtro es una gran manera de empaquetar el filtro sin contaminar el espacio de nombres global. Esto también le da más flexibilidad al desarrollador a costa de una pequeña sobrecarga.


\subsection{Sustituyendo los filtros predeterminados}
\label{advanced:sustituyendo-los-filtros-predeterminados}
Si algunos filtros predeterminados del núcleo no se ajustan a tus necesidades, los puedes sustituir fácilmente creando tu propia extensión del núcleo. Por supuesto, no es necesario copiar y pegar el código del núcleo en toda tu extensión de \emph{Twig}. En lugar de eso la puedes extender y sustituir los filtros que deseas reemplazando el método \code{getFilters()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyCoreExtension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Core}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getFilters}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{array\PYGZus{}merge}\PYG{p}{(}\PYG{k}{parent}\PYG{o}{::}\PYG{n+na}{getFilters}\PYG{p}{(),} \PYG{k}{array}\PYG{p}{(}
            \PYG{l+s+s1}{'date'} \PYG{o}{=\textgreater{}} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Filter\PYGZus{}Method}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}this}\PYG{p}{,} \PYG{l+s+s1}{'dateFilter'}\PYG{p}{),}
            \PYG{c+c1}{// ...}
        \PYG{p}{));}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{dateFilter}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}timestamp}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}format} \PYG{o}{=} \PYG{l+s+s1}{'F j, Y H:i'}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+s+s1}{'...'}\PYG{o}{.}\PYG{n+nx}{twig\PYGZus{}date\PYGZus{}format\PYGZus{}filter}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}timestamp}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}format}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Aquí, reemplazamos el filtro \code{date} con uno personalizado. Usar esta nueva extensión del núcleo es tan simple como registrar la extensión \code{MyCoreExtension} llamando al método \code{addExtension()} en la instancia del entorno:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{MyCoreExtension}\PYG{p}{());}
\end{Verbatim}

Pero ya puedo escuchar a algunas personas preguntando cómo pueden hacer que la extensión del núcleo se cargue por omisión. Eso es cierto, pero el truco es que ambas extensiones comparten el mismo identificador único (\code{core} - definido en el método \code{getName()}). Al registrar una extensión con el mismo nombre que una ya existente, realmente sustituyes la predeterminada, incluso si ya está registrada:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Core}\PYG{p}{());}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{MyCoreExtension}\PYG{p}{());}
\end{Verbatim}


\section{Etiquetas}
\label{advanced:id4}
Puedes agregar una etiqueta en una extensión reemplazando el método \code{getTokenParsers()}. Este método debe devolver una matriz de etiquetas para añadir al entorno \emph{Twig}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Twig\PYGZus{}Extension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getTokenParsers}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{array}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{Project\PYGZus{}Set\PYGZus{}TokenParser}\PYG{p}{());}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

En el código anterior, hemos añadido una sola etiqueta nueva, definida por la clase \code{Project\_Set\_TokenParser}. La clase \code{Project\_Set\_TokenParser} es responsable de analizar la etiqueta y compilarla a \emph{PHP}.


\section{Operadores}
\label{advanced:operadores}
El método \code{getOperators()} te permite añadir nuevos operadores. Aquí tienes cómo añadir los operadores
\code{!}, \code{\textbar{}\textbar{}} y \code{\&\&}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Twig\PYGZus{}Extension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getOperators}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{array}\PYG{p}{(}
            \PYG{k}{array}\PYG{p}{(}
                \PYG{l+s+s1}{'!'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}  \PYG{l+s+s1}{'precedence'} \PYG{o}{=\textgreater{}} \PYG{l+m+mi}{50}\PYG{p}{,}
                               \PYG{l+s+s1}{'class'}
                               \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'Twig\PYGZus{}Node\PYGZus{}Expression\PYGZus{}Unary\PYGZus{}Not'}
                       \PYG{p}{),}
            \PYG{p}{),}
            \PYG{k}{array}\PYG{p}{(}
                \PYG{l+s+s1}{'\textbar{}\textbar{}'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}  \PYG{l+s+s1}{'precedence'} \PYG{o}{=\textgreater{}} \PYG{l+m+mi}{10}\PYG{p}{,}
                                \PYG{l+s+s1}{'class'}
                                \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'Twig\PYGZus{}Node\PYGZus{}Expression\PYGZus{}Binary\PYGZus{}Or'}\PYG{p}{,}
                                \PYG{l+s+s1}{'associativity'}
                                \PYG{o}{=\textgreater{}} \PYG{n+nx}{Twig\PYGZus{}ExpressionParser}\PYG{o}{::}\PYG{n+na}{OPERATOR\PYGZus{}LEFT}
                        \PYG{p}{),}
                \PYG{l+s+s1}{'\&\&'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}  \PYG{l+s+s1}{'precedence'} \PYG{o}{=\textgreater{}} \PYG{l+m+mi}{15}\PYG{p}{,}
                                \PYG{l+s+s1}{'class'}
                                \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'Twig\PYGZus{}Node\PYGZus{}Expression\PYGZus{}Binary\PYGZus{}And'}\PYG{p}{,}
                                \PYG{l+s+s1}{'associativity'}
                                \PYG{o}{=\textgreater{}} \PYG{n+nx}{Twig\PYGZus{}ExpressionParser}\PYG{o}{::}\PYG{n+na}{OPERATOR\PYGZus{}LEFT}
                             \PYG{p}{),}
            \PYG{p}{),}
        \PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{Pruebas}
\label{advanced:pruebas}
El método \code{getTests()} te permite añadir funciones de prueba:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Project\PYGZus{}Twig\PYGZus{}Extension} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Extension}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{getTests}\PYG{p}{()}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{array}\PYG{p}{(}
            \PYG{l+s+s1}{'even'} \PYG{o}{=\textgreater{}} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Test\PYGZus{}Function}\PYG{p}{(}\PYG{l+s+s1}{'twig\PYGZus{}test\PYGZus{}even'}\PYG{p}{),}
        \PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\part{\emph{Twig} por dentro}
\label{internals:twig-por-dentro}\label{internals:rot13}\label{internals::doc}
\emph{Twig} es muy extensible y lo puedes mejorar fácilmente. Ten en cuenta que probablemente deberías tratar de crear una extensión antes de sumergirte en el núcleo, puesto que la mayoría de las características y mejoras se pueden hacer con extensiones. Este capítulo también es útil para personas que quieren entender cómo funciona \emph{Twig} bajo el capó.


\chapter{¿Cómo funciona \emph{Twig}?}
\label{internals:como-funciona-twig}
La reproducción de una plantilla \emph{Twig} se puede resumir en cuatro pasos fundamentales:
\begin{itemize}
\item {} 
\textbf{Cargar} la plantilla: Si la plantilla ya está compilada, la carga y va al paso \emph{evaluación}, de lo contrario:
\begin{itemize}
\item {} 
En primer lugar, el \textbf{analizador léxico} reduce el código fuente de la plantilla a pequeñas piezas para facilitar su procesamiento;

\item {} 
A continuación, el \textbf{analizador} convierte el flujo del segmento en un árbol de nodos significativo (el árbol de sintaxis abstracta);

\item {} 
Eventualmente, el \emph{compilador} transforma el árbol de sintaxis abstracta en código \emph{PHP};

\end{itemize}

\item {} 
\textbf{Evaluar} la plantilla: Básicamente significa llamar al método \code{display()} de la plantilla compilada adjuntando el contexto.

\end{itemize}


\chapter{El analizador léxico}
\label{internals:el-analizador-lexico}
El analizador léxico acorta el código fuente de una plantilla hasta una secuencia de símbolos (cada símbolo es una instancia de \code{Twig\_Token}, y la secuencia es una instancia de \code{Twig\_TokenStream}). El analizador léxico por omisión reconoce 13 diferentes tipos de símbolos:
\begin{itemize}
\item {} 
\code{Twig\_Token::BLOCK\_START\_TYPE}, \code{Twig\_Token::BLOCK\_END\_TYPE}: Delimitadores para bloques (\code{\{\% \%\}})

\item {} 
\code{Twig\_Token::VAR\_START\_TYPE}, \code{Twig\_Token::VAR\_END\_TYPE}: Delimitadores para variables (\code{\{\{ \}\}})

\item {} 
\code{Twig\_Token::TEXT\_TYPE}: Un texto fuera de una expresión;

\item {} 
\code{Twig\_Token::NAME\_TYPE}: Un nombre en una expresión;

\item {} 
\code{Twig\_Token::NUMBER\_TYPE}: Un número en una expresión;

\item {} 
\code{Twig\_Token::STRING\_TYPE}: Una cadena en una expresión;

\item {} 
\code{Twig\_Token::OPERATOR\_TYPE}: Un operador;

\item {} 
\code{Twig\_Token::PUNCTUATION\_TYPE}: Un signo de puntuacion;

\item {} 
\code{Twig\_Token::INTERPOLATION\_START\_TYPE}, \code{Twig\_Token::INTERPOLATION\_END\_TYPE} (a partir de la ramita 1,5): Los delimitadores para la interpolación de cadenas;

\item {} 
\code{Twig\_Token::EOF\_TYPE}: Extremos de la plantilla.

\end{itemize}

Puedes convertir manualmente un código fuente en una secuencia de segmentos llamando al método \code{tokenize()} de un entorno:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}stream} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{tokenize}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}source}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}identifier}\PYG{p}{);}
\end{Verbatim}

Dado que el flujo tiene un método \code{\_\_toString()}, puedes tener una representación textual del mismo haciendo eco del objeto:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}stream}\PYG{o}{.}\PYG{l+s+s2}{"}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{"}\PYG{p}{;}
\end{Verbatim}

Aquí está la salida para la plantilla \code{Hello \{\{ name \}\}}:

\begin{Verbatim}[commandchars=\\\{\}]
TEXT\PYGZus{}TYPE(Hello )
VAR\PYGZus{}START\PYGZus{}TYPE()
NAME\PYGZus{}TYPE(name)
VAR\PYGZus{}END\PYGZus{}TYPE()
EOF\PYGZus{}TYPE()
\end{Verbatim}

\begin{notice}{note}{Nota:}
Puedes cambiar el analizador léxico predeterminado usado por \emph{Twig} (\code{Twig\_Lexer}) llamando al método \code{setLexer()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{setLexer}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}lexer}\PYG{p}{);}
\end{Verbatim}
\end{notice}


\chapter{El analizador sintáctico}
\label{internals:el-analizador-sintactico}
El analizador convierte la secuencia de símbolos en un \code{ASA} (árbol de sintaxis abstracta), o un árbol de nodos (una instancia de \code{Twig\_Node\_Module}). La extensión del núcleo define los nodos básicos como: \code{for}, \code{if}, ... y la expresión nodos.

Puedes convertir manualmente una secuencia de símbolos en un nodo del árbol llamando al método \code{parse()} de un entorno:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}nodes} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{parse}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}stream}\PYG{p}{);}
\end{Verbatim}

Al hacer eco del objeto nodo te da una buena representación del árbol:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{echo} \PYG{n+nv}{\PYGZdl{}nodes}\PYG{o}{.}\PYG{l+s+s2}{"}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{"}\PYG{p}{;}
\end{Verbatim}

Aquí está la salida para la plantilla \code{Hello \{\{ name \}\}}:

\begin{Verbatim}[commandchars=\\\{\}]
Twig\PYGZus{}Node\PYGZus{}Module(
  Twig\PYGZus{}Node\PYGZus{}Text(Hello )
  Twig\PYGZus{}Node\PYGZus{}Print(
    Twig\PYGZus{}Node\PYGZus{}Expression\PYGZus{}Name(name)
  )
)
\end{Verbatim}

\begin{notice}{note}{Nota:}
También puedes cambiar el analizador predeterminado (\code{Twig\_TokenParser}) llamando al método \code{setParser()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{setParser}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}analizador}\PYG{p}{);}
\end{Verbatim}
\end{notice}


\chapter{El compilador}
\label{internals:el-compilador}
El último paso lo lleva a cabo el compilador. Este necesita un árbol de nodos como entrada y genera código \emph{PHP} que puedes emplear para ejecutar las plantillas en tiempo de ejecución.

Puedes llamar al compilador manualmente con el método \code{compile()} de un entorno:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}php} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{compile}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}nodes}\PYG{p}{);}
\end{Verbatim}

El método \code{compile()} devuelve el código fuente \emph{PHP} que representa al nodo.

La plantilla generada por un patrón \code{Hello \{\{ name \}\}} es la siguiente (la salida real puede diferir dependiendo de la versión de \emph{Twig} que estés usando):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Hello \PYGZob{}\PYGZob{} name \PYGZcb{}\PYGZcb{} */}
\PYG{k}{class} \PYG{n+nc}{\PYGZus{}\PYGZus{}TwigTemplate\PYGZus{}1121b6f109fe93ebe8c6e22e3712bceb} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Template}
\PYG{p}{\PYGZob{}}
    \PYG{k}{protected} \PYG{k}{function} \PYG{n+nf}{doDisplay}\PYG{p}{(}\PYG{k}{array} \PYG{n+nv}{\PYGZdl{}context}\PYG{p}{,} \PYG{k}{array} \PYG{n+nv}{\PYGZdl{}blocks} \PYG{o}{=} \PYG{k}{array}\PYG{p}{())}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// line 1}
        \PYG{k}{echo} \PYG{l+s+s2}{"}\PYG{l+s+s2}{Hello }\PYG{l+s+s2}{"}\PYG{p}{;}
        \PYG{k}{echo} \PYG{n+nx}{twig\PYGZus{}escape\PYGZus{}filter}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{env}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{getContext}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}context}\PYG{p}{,} \PYG{l+s+s2}{"}\PYG{l+s+s2}{name}\PYG{l+s+s2}{"}\PYG{p}{),} \PYG{l+s+s2}{"}\PYG{l+s+s2}{ndex}\PYG{l+s+s2}{"}\PYG{p}{,} \PYG{k}{null}\PYG{p}{,} \PYG{k}{true}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// algún código adicional}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
En cuanto a los analizadores léxico y sintáctico, el compilador predeterminado (\code{Twig\_Compiler}) se puede cambiar mediante una llamada al método \code{setCompiler()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{setCompiler}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}compilador}\PYG{p}{);}
\end{Verbatim}
\end{notice}


\part{Recetas}
\label{recipes::doc}\label{recipes:recetas}

\chapter{Haciendo un diseño condicional}
\label{recipes:haciendo-un-diseno-condicional}
Trabajar con \emph{Ajax} significa que el mismo contenido a veces se muestra tal cual, y, a veces se decora con un diseño. Dado que el nombre del diseño de las plantillas \emph{Twig} puede ser cualquier expresión válida, puedes pasar una variable que evalúe a \code{true} cuando se hace la petición a través de \emph{Ajax} y elegir el diseño en consecuencia:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{n+nv}{request}\PYG{n+nv}{.ajax} \PYG{p}{?} \PYG{l+s+s2}{"base\PYGZus{}ajax.html"} \PYG{o}{:} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    Este es el contenido a mostrar.}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{Haciendo una inclusión dinámica}
\label{recipes:haciendo-una-inclusion-dinamica}
Cuando incluyes una plantilla, su nombre no tiene por qué ser una cadena. Por ejemplo, el nombre puede depender del valor de una variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{n+nv}{var} \PYG{o}{\PYGZti{}} \PYG{l+s+s1}{'\PYGZus{}foo.html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Si \code{var} evalúa como \code{index}, se reproducirá la plantilla \code{index\_foo.html}.

De hecho, el nombre de la plantilla puede ser cualquier expresión válida, como la siguiente:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'index'}\PYG{o}{)} \PYG{o}{\PYGZti{}} \PYG{l+s+s1}{'\PYGZus{}foo.html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{Sustituyendo una plantilla que además se extiende a sí misma}
\label{recipes:sustituyendo-una-plantilla-que-ademas-se-extiende-a-si-misma}
Puedes personalizar una plantilla de dos formas diferentes:
\begin{itemize}
\item {} 
\emph{Herencia}: Una plantilla \emph{extiende} a una plantilla padre y sustituye algunos bloques;

\item {} 
\emph{Sustitución}: Si utilizas el cargador del sistema de archivos, \emph{Twig} carga la primera plantilla que encuentre en una lista de directorios configurados; una plantilla que se encuentra en un directorio \emph{sustituye} a otra de un directorio más en la lista.

\end{itemize}

Pero, ¿cómo se combinan las dos cosas?: \emph{sustituir} una plantilla que también se extiende a sí misma (también conocida como una plantilla en un directorio más en la lista)

Digamos que tus plantillas se cargan tanto desde \code{.../templates/mysite} como de \code{.../templates/default}, en este orden. La plantilla \code{page.twig} almacenada en \code{../templates/default} es la siguiente:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} page.twig \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.twig"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Puedes sustituir esta plantilla poniendo un archivo con el mismo nombre en \code{.../templates/mysite}. Y si deseas ampliar la plantilla original, podrías tener la tentación de escribir lo siguiente:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} page.twig in .../templates/mysite \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"page.twig"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} from .../templates/default \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Por supuesto, esto no funcionará debido a que \emph{Twig} siempre carga la plantilla desde \code{.../templates/mysite}.

Resulta que es posible conseguir que esto funcione, añadiendo el directorio adecuado al final de tus directorios de plantilla, el cual es el padre de todos los otros directorios: \code{.../templates} en nuestro caso. Esto tiene el efecto de hacer que cada archivo de plantilla dentro de nuestro sistema sea direccionable unívocamente. La mayoría de las veces utilizarás rutas ``normales'', pero en el caso especial de querer extender una plantilla con una versión que se redefine a sí misma podemos referirnos a la ruta completa del padre, sin ambigüedades, en la etiqueta \code{extends} de la plantilla:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} page.twig in .../templates/mysite \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"default/page.twig"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} from .../templates \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Esta receta está inspirada en la página ``Extendiendo plantillas'' del \emph{wiki} de \emph{Django}:
La puedes ver \href{http://code.djangoproject.com/wiki/ExtendingTemplates}{aquí}
\end{notice}


\chapter{Personalizando la sintaxis}
\label{recipes:personalizando-la-sintaxis}
\emph{Twig} te permite personalizar alguna sintaxis de los delimitadores de bloque. No se recomienda usar esta característica puesto que las plantillas serán vinculadas con tu sintaxis personalizada. Sin embargo, para proyectos específicos, puede tener sentido cambiar los valores predeterminados.

Para cambiar los delimitadores de bloque, necesitas crear tu propio objeto analizador sintáctico (o \emph{lexer}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{();}

\PYG{n+nv}{\PYGZdl{}lexer} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Lexer}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}twig}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'tag\PYGZus{}comment'}  \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\PYGZob{}\PYGZsh{}'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZsh{}\PYGZcb{}'}\PYG{p}{),}
    \PYG{l+s+s1}{'tag\PYGZus{}block'}    \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\PYGZob{}\PYGZpc{}'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZpc{}\PYGZcb{}'}\PYG{p}{),}
    \PYG{l+s+s1}{'tag\PYGZus{}variable'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\PYGZob{}\PYGZob{}'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZcb{}\PYGZcb{}'}\PYG{p}{),}
\PYG{p}{));}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{setLexer}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}lexer}\PYG{p}{);}
\end{Verbatim}

Éstos son algunos ejemplos de configuración que simulan la sintaxis de algunos otros motores de plantilla:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// sintaxis erb de Ruby}
\PYG{n+nv}{\PYGZdl{}lexer} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Lexer}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}twig}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'tag\PYGZus{}comment'}  \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\textless{}\PYGZpc{}\PYGZsh{}'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZpc{}\textgreater{}'}\PYG{p}{),}
    \PYG{l+s+s1}{'tag\PYGZus{}block'}    \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\textless{}\PYGZpc{}'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZpc{}\textgreater{}'}\PYG{p}{),}
    \PYG{l+s+s1}{'tag\PYGZus{}variable'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\textless{}\PYGZpc{}='}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZpc{}\textgreater{}'}\PYG{p}{),}
\PYG{p}{));}

\PYG{c+c1}{// sintaxis de comentarios SGML}
\PYG{n+nv}{\PYGZdl{}lexer} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Lexer}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}twig}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'tag\PYGZus{}comment'}  \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\textless{}!--\PYGZsh{}'}\PYG{p}{,} \PYG{l+s+s1}{'--\textgreater{}'}\PYG{p}{),}
    \PYG{l+s+s1}{'tag\PYGZus{}block'}    \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\textless{}!--'}\PYG{p}{,} \PYG{l+s+s1}{'--\textgreater{}'}\PYG{p}{),}
    \PYG{l+s+s1}{'tag\PYGZus{}variable'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\PYGZdl{}\PYGZob{}'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZcb{}'}\PYG{p}{),}
\PYG{p}{));}

\PYG{c+c1}{// como Smarty}
\PYG{n+nv}{\PYGZdl{}lexer} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Lexer}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}twig}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'tag\PYGZus{}comment'}  \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\PYGZob{}*'}\PYG{p}{,} \PYG{l+s+s1}{'*\PYGZcb{}'}\PYG{p}{),}
    \PYG{l+s+s1}{'tag\PYGZus{}block'}    \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\PYGZob{}'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZcb{}'}\PYG{p}{),}
    \PYG{l+s+s1}{'tag\PYGZus{}variable'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'\PYGZob{}\PYGZdl{}'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZcb{}'}\PYG{p}{),}
\PYG{p}{));}
\end{Verbatim}


\chapter{Usando propiedades dinámicas de objetos}
\label{recipes:usando-propiedades-dinamicas-de-objetos}
Cuando \emph{Twig} encuentra una variable como \code{articulo.titulo}, trata de encontrar una propiedad pública \code{titulo} en el objeto \code{articulo}.

También funciona si la propiedad no existe, pero más bien está definida de forma dinámica gracias a la magia del método \code{\_\_get()}; sólo tienes que implementar también el método mágico \code{\_\_isset()}, como muestra el siguiente fragmento de código:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Article}
\PYG{p}{\PYGZob{}}
    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{\PYGZus{}\PYGZus{}get}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{l+s+s1}{'title'} \PYG{o}{==} \PYG{n+nv}{\PYGZdl{}name}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{l+s+s1}{'The title'}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// lanza algún tipo de error}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{\PYGZus{}\PYGZus{}isset}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{l+s+s1}{'title'} \PYG{o}{==} \PYG{n+nv}{\PYGZdl{}name}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{k}{true}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{k}{false}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\chapter{Accediendo al contexto del padre en bucles anidados}
\label{recipes:accediendo-al-contexto-del-padre-en-bucles-anidados}
A veces, cuando utilizas bucles anidados, necesitas acceder al contexto del padre. El contexto del padre siempre es accesible a través de la variable \code{loop.parent}. Por ejemplo, si tienes los siguientes datos de plantilla:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}datos} \PYG{o}{=} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'temas'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}
        \PYG{l+s+s1}{'tema1'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'Mensaje 1 del tema 1'}\PYG{p}{,} \PYG{l+s+s1}{'Mensaje 2 del tema 1'}\PYG{p}{),}
        \PYG{l+s+s1}{'tema2'} \PYG{o}{=\textgreater{}} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'Mensaje 1 del tema 2'}\PYG{p}{,} \PYG{l+s+s1}{'Mensaje 2 del tema 2'}\PYG{p}{),}
    \PYG{p}{),}
\PYG{p}{);}
\end{Verbatim}

Y la siguiente plantilla para mostrar todos los mensajes en todos los temas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{topic}\PYG{o}{,} \PYG{n+nv}{messages} \PYG{k}{in} \PYG{n+nv}{topics} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    * }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nb}{loop}\PYG{n+nv}{.index} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{: }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{topic} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{  }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{message} \PYG{k}{in} \PYG{n+nv}{messages} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{      - }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nb}{loop}\PYG{n+nv}{.parent}\PYG{n+nv}{.loop}\PYG{n+nv}{.index} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{.}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nb}{loop}\PYG{n+nv}{.index} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{: }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{message} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{  }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Reproducirá algo similar a:

\begin{Verbatim}[commandchars=\\\{\}]
* 1: topic1
  - 1.1: The message 1 of topic 1
  - 1.2: The message 2 of topic 1
* 2: topic2
  - 2.1: The message 1 of topic 2
  - 2.2: The message 2 of topic 2
\end{Verbatim}

En el bucle interno, utilizamos la variable \code{loop.parent} para acceder al contexto externo. Así, el índice del \code{tema} actual definido en el exterior del bucle es accesible a través de la variable \code{loop.parent.loop.index}.


\chapter{Definiendo al vuelo funciones indefinidas y filtros}
\label{recipes:definiendo-al-vuelo-funciones-indefinidas-y-filtros}
Cuando una función (o un filtro) no está definido, de manera predeterminada \emph{Twig} lanza una excepción \code{Twig\_Error\_Syntax}. Sin embargo, también puede invocar una \href{http://www.php.net/manual/es/function.is-callable.php}{retrollamada} (cualquier \emph{PHP} válido que se pueda ejecutar) la cual debe devolver una función (o un filtro).

Para filtros, registra las retrollamadas con \code{registerUndefinedFilterCallback()}.
Para funciones, usa \code{registerUndefinedFunctionCallback()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Autoregistra todas las funciones nativas de PHP como funciones Twig}
\PYG{c+c1}{// no intentes esto en casa, ¡ya que no es seguro en absoluto!}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{registerUndefinedFunctionCallback}\PYG{p}{(}\PYG{k}{function} \PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{function\PYGZus{}exists}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{))} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Function\PYGZus{}Function}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}name}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{return} \PYG{k}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{});}
\end{Verbatim}

Si el ejecutable no es capaz de devolver una función válida (o filtro), deberá devolver \code{false}.

Si registras más de una retrollamada, \emph{Twig} la llamará a su vez hasta que una no devuelva \code{false}.

\begin{notice}{tip}{Truco:}
Debido a que la resolución de funciones y filtros se realiza durante la compilación, no hay ninguna sobrecarga cuando registras estas retrollamadas.
\end{notice}


\chapter{Validando la sintaxis de la plantilla}
\label{recipes:validando-la-sintaxis-de-la-plantilla}
Cuando el código de plantilla lo proporciona un tercero (a través de una interfaz web, por ejemplo), podría ser interesante validar la sintaxis de la plantilla antes de guardarla. Si el código de la plantilla se almacena en una variable \code{\$template}, así es cómo lo puedes hacer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try} \PYG{p}{\PYGZob{}}
    \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{parse}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{tokenize}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}template}\PYG{p}{));}

    \PYG{c+c1}{// \PYGZdl{}template  es válida}
\PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Error\PYGZus{}Syntax} \PYG{n+nv}{\PYGZdl{}e}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// \PYGZdl{}template contiene uno o más errores de sintaxis}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Si iteras sobre una serie de archivos, puedes suministrar el nombre de archivo al método \code{tokenize()} para tener el nombre de archivo en el mensaje de la excepción:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{foreach} \PYG{p}{(}\PYG{n+nv}{\PYGZdl{}files} \PYG{k}{as} \PYG{n+nv}{\PYGZdl{}file}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{try} \PYG{p}{\PYGZob{}}
        \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{parse}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{tokenize}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}template}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}file}\PYG{p}{));}

        \PYG{c+c1}{// la \PYGZdl{}template  es válida}
    \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}Error\PYGZus{}Syntax} \PYG{n+nv}{\PYGZdl{}e}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// la \PYGZdl{}template contiene uno o más errores de sintaxis}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Este método no atrapa ninguna violación de las políticas del recinto de seguridad porque la política se aplica durante la reproducción de la plantilla (debido a que \emph{Twig} necesita el contexto para comprobar los métodos permitidos en los objetos).
\end{notice}


\chapter{Actualizando plantillas modificadas cuando \emph{APC} está habilitado y \texttt{apc.stat=0}}
\label{recipes:actualizando-plantillas-modificadas-cuando-apc-esta-habilitado-y-apc-stat-0}
Cuando utilizas \emph{APC} con \code{apc.stat} establecido en \code{0} y está habilitada la memorización en caché de \emph{Twig}, borra la caché de la plantilla que no va a actualizar la memoria caché \emph{APC}. Para evitar esto, puedes extender \code{Twig\_Environment} y forzar la actualización de la caché \emph{APC} cuando \emph{Twig} reescriba la memoria caché:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Twig\PYGZus{}Environment\PYGZus{}APC} \PYG{k}{extends} \PYG{n+nx}{Twig\PYGZus{}Environment}
\PYG{p}{\PYGZob{}}
    \PYG{k}{protected} \PYG{k}{function} \PYG{n+nf}{writeCacheFile}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}file}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}content}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{parent}\PYG{o}{::}\PYG{n+na}{writeCacheFile}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}file}\PYG{p}{,} \PYG{n+nv}{\PYGZdl{}content}\PYG{p}{);}

        \PYG{c+c1}{// Archivo memorizado y compilado a bytecode}
        \PYG{n+nx}{apc\PYGZus{}compile\PYGZus{}file}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}file}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\chapter{Reutilizando el estado de un visitante de nodo}
\label{recipes:reutilizando-el-estado-de-un-visitante-de-nodo}
Al asociar un visitante a una instancia de \code{Twig\_Environment}, \emph{Twig} lo utilizará para visitar \emph{todas} las plantillas que compile. Si necesitas mantener cierta información de estado, probablemente desees restablecerla cuando visites una nueva plantilla.

Lo puedes lograr fácilmente con el siguiente código:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{protected} \PYG{n+nv}{\PYGZdl{}someTemplateState} \PYG{o}{=} \PYG{k}{array}\PYG{p}{();}

\PYG{k}{public} \PYG{k}{function} \PYG{n+nf}{enterNode}\PYG{p}{(}\PYG{n+nx}{Twig\PYGZus{}NodeInterface} \PYG{n+nv}{\PYGZdl{}node}\PYG{p}{,} \PYG{n+nx}{Twig\PYGZus{}Environment} \PYG{n+nv}{\PYGZdl{}env}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nv}{\PYGZdl{}node} \PYG{n+nx}{instanceof} \PYG{n+nx}{Twig\PYGZus{}Node\PYGZus{}Module}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{Restablece} \PYG{n+nx}{el} \PYG{n+nx}{estado} \PYG{n+nx}{puesto} \PYG{n+nx}{que} \PYG{n+nx}{estamos} \PYG{n+nx}{entrando} \PYG{n+nx}{en} \PYG{n+nx}{una}
        \PYG{c+c1}{// nueva plantilla}
        \PYG{n+nv}{\PYGZdl{}this}\PYG{o}{-\textgreater{}}\PYG{n+na}{someTemplateState} \PYG{o}{=} \PYG{k}{array}\PYG{p}{();}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// ...}

    \PYG{k}{return} \PYG{n+nv}{\PYGZdl{}node}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\chapter{Usando el nombre de la plantilla para determinar la estrategia de escape predeterminada}
\label{recipes:usando-el-nombre-de-la-plantilla-para-determinar-la-estrategia-de-escape-predeterminada}Nuevo en la versión 1.8: Esta receta requiere \emph{Twig 1.8} o posterior.
El opción \code{autoescape} determina la estrategia de escapar predefinida a utilizar cuando no se aplica escape a una variable. Cuando utilizas \emph{Twig} para generar en su mayoría archivos \emph{HTML}, la puedes establecer a \code{html} y cambiarla explícitamente a \code{js} cuando tengas algunos archivos \emph{JavaScript} dinámicos gracias a la etiqueta \code{autoescape}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{n+nv}{js} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ... algún JS ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Pero si tienes muchos archivos \emph{HTML} y \emph{JS}, y si tus nombres de plantilla siguen algunas convenciones, en su lugar puedes determinar la estrategia de escapar a usar en función del nombre de la plantilla. Digamos que tus nombres de plantilla siempre terminan con \code{.html} para archivos \emph{HTML} y \code{.js} para los de \emph{JavaScript}, aquí tienes cómo puedes configurar a \emph{Twig}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{function} \PYG{n+nf}{twig\PYGZus{}escaping\PYGZus{}guesser}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}filename}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// obtiene el formato}
    \PYG{n+nv}{\PYGZdl{}format} \PYG{o}{=} \PYG{n+nb}{substr}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}filename}\PYG{p}{,} \PYG{n+nb}{strrpos}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}filename}\PYG{p}{,} \PYG{l+s+s1}{'.'}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{);}

    \PYG{k}{switch} \PYG{p}{(}\PYG{n+nv}{\PYGZdl{}format}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s1}{'js'}\PYG{o}{:}
            \PYG{k}{return} \PYG{l+s+s1}{'js'}\PYG{p}{;}
        \PYG{k}{default}\PYG{o}{:}
            \PYG{k}{return} \PYG{l+s+s1}{'html'}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n+nv}{\PYGZdl{}loader} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Loader\PYGZus{}Filesystem}\PYG{p}{(}\PYG{l+s+s1}{'/ruta/a/templates'}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'autoescape'} \PYG{o}{=\textgreater{}} \PYG{l+s+s1}{'twig\PYGZus{}escaping\PYGZus{}guesser'}\PYG{p}{,}
\PYG{p}{));}
\end{Verbatim}

Esta estrategia dinámica no incurre en ningún tipo de sobrecarga en tiempo de ejecución como lo hace el autoescape en tiempo de compilación.


\part{Estándares de codificación}
\label{coding_standards:retrollamada}\label{coding_standards::doc}\label{coding_standards:estandares-de-codificacion}
Al escribir plantillas \emph{Twig}, te recomendamos que sigas las siguientes normas de codificación oficiales:
\begin{itemize}
\item {} 
Deja un espacio (y sólo uno) después de un delimitador inicial (\code{\{\{}, \code{\{\%}, y \code{\{\#}) y antes del final de un delimitador (\code{\}\}}, \code{\%\}}, y \code{\#\}}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{foo} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c}{\PYGZob{}\PYGZsh{} comentario \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{foo} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Cuando utilices los caracteres de guión junto con el espacio en blanco, no dejes ningún espacio entre este y el delimitador:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}}\PYG{o}{-} \PYG{n+nv}{foo} -\PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c}{\PYGZob{}\PYGZsh{}- comentario -\PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}}- \PYG{k}{if} \PYG{n+nv}{foo} -\PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}}- \PYG{k}{endif} -\PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\item {} 
Deja un espacio (y sólo uno) antes y después de los siguientes operadores:
operadores de comparación (\code{==}, \code{!=}, \code{\textless{}}, \code{\textgreater{}}, \code{\textgreater{}=}, \code{\textless{}=}), operadores matemáticos (\code{+}, \code{-}, \code{/}, \code{*}, \code{\%}, \code{//}, \code{**}), operadores lógicos (\code{not}, \code{and}, \code{or}), \code{\textasciitilde{}}, \code{is}, \code{in}, y el operador ternario (\code{?:}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZob{} 1 + 2 \PYGZcb{}\PYGZcb{}
\PYGZob{}\PYGZob{} foo \textasciitilde{} bar \PYGZcb{}\PYGZcb{}
\PYGZob{}\PYGZob{} true ? true : false \PYGZcb{}\PYGZcb{}
\end{Verbatim}

\item {} 
Deja un espacio (y sólo uno) después del signo \code{:} en \code{hashes} (o \code{codificaciones} en adelante), y la \code{,} en arreglos y codificaciones:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{]} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\item {} 
No dejes ningún espacio después de un paréntesis de apertura y antes de un paréntesis de cierre en expresiones:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+m}{1} \PYG{o}{+} \PYG{o}{(}\PYG{l+m}{2} \PYG{o}{*} \PYG{l+m}{3}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\item {} 
No dejes ningún espacio en blanco antes y después de los delimitadores de cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'foo'} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"foo"} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\item {} 
No dejes ningún espacio en blanco antes y después de los siguientes operadores: \code{\textbar{}}, \code{.}, \code{..}, \code{{[}{]}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{foo}\PYG{o}{\textbar{}}\PYG{n+nf}{upper}\PYG{o}{\textbar{}}\PYG{n+nf}{lower} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.name} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{o}{[}\PYG{n+nv}{name}\PYG{o}{]} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{l+m}{1.}\PYG{n+nv}{.12} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\item {} 
No dejes ningún espacio en blanco antes y después de los paréntesis utilizados en filtros y llamadas a función:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{foo}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'foo'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{range}\PYG{o}{(}\PYG{l+m}{1.}\PYG{n+nv}{.10}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\item {} 
No dejes ningún espacio en blanco antes y después de la apertura de arreglos y codificaciones:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{]} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\item {} 
Utiliza letras minúsculas y guiones bajos en nombres de variables:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{l+s+s1}{'foo'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo\PYGZus{}bar} \PYG{o}{=} \PYG{l+s+s1}{'foo'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\item {} 
Sangra tu código dentro de las etiquetas (usa la misma profundidad que la utilizada en el lenguaje principal del archivo):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{foo} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{   }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{k+kp}{true} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{       true}
\PYG{x}{   }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\end{itemize}


\part{Etiquetas}
\label{tags/index:etiquetas}\label{tags/index::doc}

\chapter{\texttt{for}}
\label{tags/for::doc}\label{tags/for:for}
Recorre cada elemento de una secuencia. Por ejemplo, para mostrar una lista de usuarios provista en una variable llamada \code{usuarios}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}h1\textgreater{}Members\textless{}/h1\textgreater{}}
\PYG{x}{\textless{}ul\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{\textless{}/ul\textgreater{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Una secuencia puede ser una matriz o un objeto que implementa la interfaz \code{Traversable}.
\end{notice}

Si necesitas iterar en una secuencia de números, el operador \code{..} es muy útil:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{l+m}{0.}\PYG{n+nv}{.10} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    * }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{i} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

El fragmento de código anterior debería imprimir todos los números del 0 al 10.

También lo puedes utilizar con letras:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{letter} \PYG{k}{in} \PYG{l+s+s1}{'a'}\PYG{p}{.}\PYG{p}{.}\PYG{l+s+s1}{'z'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    * }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{letter} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

El operador \code{..} puede tomar cualquier expresión en ambos lados:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{letter} \PYG{k}{in} \PYG{l+s+s1}{'a'}\PYG{o}{\textbar{}}\PYG{n+nf}{upper}\PYG{p}{.}\PYG{p}{.}\PYG{l+s+s1}{'z'}\PYG{o}{\textbar{}}\PYG{n+nf}{upper} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    * }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{letter} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\section{La variable \texttt{loop}}
\label{tags/for:la-variable-loop}
Dentro de un bloque de bucle \code{for} puedes acceder a algunas variables especiales:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
Variable
} & \textbf{
Descripción
}\\\hline

\code{loop.index}
 & 
La iteración actual del bucle. (indexada en 1)
\\\hline

\code{loop.index0}
 & 
La iteración actual del bucle. (indexada en 0)
\\\hline

\code{loop.revindex}
 & 
El número de iteraciones a partir del final del bucle (indexadas en 1)
\\\hline

\code{loop.revindex0}
 & 
El número de iteraciones a partir del final del bucle (indexadas en 0)
\\\hline

\code{loop.first}
 & 
\code{True} si es la primera iteración
\\\hline

\code{loop.last}
 & 
\code{True} si es la última iteración
\\\hline

\code{loop.length}
 & 
El número de elementos en la secuencia
\\\hline

\code{loop.parent}
 & 
El contexto del padre
\\\hline
\end{tabulary}


\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nb}{loop}\PYG{n+nv}{.index} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ - }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Las variables \code{loop.length}, \code{loop.revindex}, \code{loop.revindex0} y \code{loop.last} únicamente están disponibles para matrices \emph{PHP}, u objetos que implementen la interfaz \code{Countable}. Tampoco están disponibles cuando iteras con una condición.
\end{notice}
Nuevo en la versión 1.2: La compatibilidad con el modificador \code{if} se añadió en \emph{Twig} 1.2.

\section{Añadiendo una condición}
\label{tags/for:anadiendo-una-condicion}
A diferencia de \emph{PHP}, en un bucle no es posible usar \code{break} ni \code{continue}. Sin embargo, puedes filtrar la secuencia durante la iteración, lo cual te permite omitir elementos. En el siguiente ejemplo se omiten todos los usuarios que no están activos:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}ul\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{k}{if} \PYG{n+nv}{user}\PYG{n+nv}{.active} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{\textless{}/ul\textgreater{}}
\end{Verbatim}

La ventaja es que la variable especial \code{loop} contará correctamente, es decir, sin contar a los usuarios inactivos en la iteración. Ten en cuenta que las propiedades como \code{loop.last} no están definidas cuando usas bucles condicionales.

\begin{notice}{note}{Nota:}
Usar la variable \code{loop} sin la condición no es recomendable debido a que no llevará a cabo lo que esperas se haga. Por ejemplo, añadir una condición como \code{loop.index \textgreater{} 4} no funcionará puesto que el índice únicamente se incrementa cuando la condición es cierta (por lo tanto, la condición nunca coincidirá).
\end{notice}


\section{La cláusula \texttt{else}}
\label{tags/for:la-clausula-else}
Si no se llevó a cabo iteración debido a que la secuencia está vacía, puedes reproducir un bloque sustituto utilizando \code{else}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}ul\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{else} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        \textless{}li\textgreater{}\textless{}em\textgreater{}no user found\textless{}/em\textgreater{}\textless{}/li\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{\textless{}/ul\textgreater{}}
\end{Verbatim}


\section{Iterando en las claves}
\label{tags/for:iterando-en-las-claves}
De forma predeterminada, un bucle itera en los valores de la secuencia. Puedes iterar en las claves con el filtro \code{keys}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}h1\textgreater{}Members\textless{}/h1\textgreater{}}
\PYG{x}{\textless{}ul\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{key} \PYG{k}{in} \PYG{n+nv}{users}\PYG{o}{\textbar{}}\PYG{n+nf}{keys} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{key} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{\textless{}/ul\textgreater{}}
\end{Verbatim}


\section{Iterando en claves y valores}
\label{tags/for:iterando-en-claves-y-valores}
También puedes acceder tanto a las claves como a los valores:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}h1\textgreater{}Members\textless{}/h1\textgreater{}}
\PYG{x}{\textless{}ul\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{key}\PYG{o}{,} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{key} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{: }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{\textless{}/ul\textgreater{}}
\end{Verbatim}


\chapter{\texttt{if}}
\label{tags/if::doc}\label{tags/if:if}
La declaración \code{if} en \emph{Twig} es comparable con las declaraciones \code{if} de \emph{PHP}.

En la forma más simple la puedes usar para probar si una expresión evalúa a \code{true}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{online} \PYG{o}{==} \PYG{k+kp}{false} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}p\textgreater{}Our website is in maintenance mode. Please, come back later.\textless{}/p\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

También puedes probar si una matriz no está vacía:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}ul\textgreater{}}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{            \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}/ul\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Si deseas probar si una variable está definida, usa \code{if usuarios is defined} en su lugar.
\end{notice}

Para ramificación múltiple puedes utilizar \code{elseif} y \code{else} como en \emph{PHP}. Allí también puedes utilizar \code{expresiones} más complejas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{kenny}\PYG{n+nv}{.sick} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    Kenny is sick.}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{elseif} \PYG{n+nv}{kenny}\PYG{n+nv}{.dead} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    You killed Kenny!  You bastard!!!}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{else} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    Kenny looks okay --- so far}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{macro}}
\label{tags/macro:macro}\label{tags/macro::doc}
Las macros son comparables con funciones en lenguajes de programación regulares. Son útiles para poner modismos \emph{HTML} utilizados frecuentemente en elementos reutilizables para no repetirlos.

He aquí un pequeño ejemplo de una macro que reproduce un elemento de formulario:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{macro} \PYG{n+nv}{input}\PYG{o}{(}\PYG{n+nv}{name}\PYG{o}{,} \PYG{n+nv}{value}\PYG{o}{,} \PYG{n+nv}{type}\PYG{o}{,} \PYG{n+nv}{size}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}input type="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{type}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'text'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             name="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{name} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             value="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{value}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             size="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{size}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+m}{2}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{" /\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endmacro} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Las macros se diferencian de las funciones \emph{PHP} nativas en varias formas:
\begin{itemize}
\item {} 
Los valores predeterminados de los argumentos se definen usando el filtro \code{default} en el cuerpo de la macro;

\item {} 
Los argumentos de una macro siempre son opcionales.

\end{itemize}

Pero como las funciones de \emph{PHP}, las macros no tienen acceso a las variables de la plantilla actual.

\begin{notice}{tip}{Truco:}
Puedes pasar todo el contexto como un argumento usando la variable especial \code{\_context}.
\end{notice}

Las macros se pueden definir en cualquier plantilla, y es necesario ``importarlas'', antes de utilizarlas (consulta la etiqueta {\hyperref[tags/import::doc]{\emph{import}}} (\autopageref*{tags/import::doc}) para más información):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{import} \PYG{l+s+s2}{"formularios.html"} \PYG{k}{as} \PYG{n+nv}{forms} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La llamada a \code{import} anterior importa el archivo ``formularios.html'' (el cual puede contener macros solamente, o una plantilla y algunas macros), e importa las funciones como elementos de la variable \code{forms}.

Entonces puedes llamar a la macro a voluntad:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}p\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{forms}\PYG{n+nv}{.input}\PYG{o}{(}\PYG{l+s+s1}{'username'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/p\textgreater{}}
\PYG{x}{\textless{}p\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{forms}\PYG{n+nv}{.input}\PYG{o}{(}\PYG{l+s+s1}{'password'}\PYG{o}{,} \PYG{n+nv}{null}\PYG{o}{,} \PYG{l+s+s1}{'password'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/p\textgreater{}}
\end{Verbatim}

Si defines macros y las utilizas en la misma plantilla, puedes usar la variable especial \code{\_self}, sin necesidad de importarlas:

\begin{Verbatim}[commandchars=\\\{\}]
\textless{}p\textgreater{}\PYGZob{}\PYGZob{} \_self.input('nombreusuario') \PYGZcb{}\PYGZcb{}\textless{}/p\textgreater{}
\end{Verbatim}

Cuando ---en el mismo archivo--- quieras utilizar una macro en otra, utiliza la variable \code{\_self}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}\% macro input(name, value, type, size) \%\PYGZcb{}
  \textless{}input type="\PYGZob{}\PYGZob{} type\textbar{}default('text') \PYGZcb{}\PYGZcb{}"
             name="\PYGZob{}\PYGZob{} name \PYGZcb{}\PYGZcb{}"
             value="\PYGZob{}\PYGZob{} value\textbar{}e \PYGZcb{}\PYGZcb{}"
             size="\PYGZob{}\PYGZob{} size\textbar{}default(20) \PYGZcb{}\PYGZcb{}" /\textgreater{}
\PYGZob{}\% endmacro \%\PYGZcb{}

\PYGZob{}\% macro wrapped\_input(name, value, type, size) \%\PYGZcb{}
    \textless{}div class="field"\textgreater{}
        \PYGZob{}\PYGZob{} \_self.input(name, value, type, size) \PYGZcb{}\PYGZcb{}
    \textless{}/div\textgreater{}
\PYGZob{}\% endmacro \%\PYGZcb{}
\end{Verbatim}

Cuando la macro está definida en otro archivo, necesitas importarla:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} formularios.html \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{macro} \PYG{n+nv}{input}\PYG{o}{(}\PYG{n+nv}{name}\PYG{o}{,} \PYG{n+nv}{value}\PYG{o}{,} \PYG{n+nv}{type}\PYG{o}{,} \PYG{n+nv}{size}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{  \textless{}input type="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{type}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'text'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             name="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{name} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             value="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{value}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             size="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{size}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+m}{2}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{" /\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endmacro} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} shortcuts.html \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{macro} \PYG{n+nv}{wrapped\PYGZus{}input}\PYG{o}{(}\PYG{n+nv}{name}\PYG{o}{,} \PYG{n+nv}{value}\PYG{o}{,} \PYG{n+nv}{type}\PYG{o}{,} \PYG{n+nv}{size}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{import} \PYG{l+s+s2}{"formularios.html"} \PYG{k}{as} \PYG{n+nv}{forms} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}div class="field"\textgreater{}}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{forms}\PYG{n+nv}{.input}\PYG{o}{(}\PYG{n+nv}{name}\PYG{o}{,} \PYG{n+nv}{value}\PYG{o}{,} \PYG{n+nv}{type}\PYG{o}{,} \PYG{n+nv}{size}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{    \textless{}/div\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endmacro} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\strong{Ver También:}


{\hyperref[tags/from::doc]{\emph{from}}} (\autopageref*{tags/from::doc}), {\hyperref[tags/import::doc]{\emph{import}}} (\autopageref*{tags/import::doc})




\chapter{\texttt{filter}}
\label{tags/filter:filter}\label{tags/filter::doc}
Filtrar secciones te permite aplicar filtros \emph{Twig} regulares en un bloque de datos de la plantilla. Simplemente envuelve el código en el bloque especial \code{filter}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{filter} \PYG{n+nf}{upper} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    Este texto cambia a mayúsculas}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfilter} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

También puedes encadenar filtros:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{filter} \PYG{n+nf}{lower}\PYG{o}{\textbar{}}\PYG{n+nf}{escape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}strong\textgreater{}ALGÚN TEXTO\textless{}/strong\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfilter} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce "\&lt;strong\&gt;some text\&lt;/strong\&gt;" \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{set}}
\label{tags/set:set}\label{tags/set::doc}
Dentro del código de los bloques también puedes asignar valores a variables. Las asignaciones utilizan la etiqueta \code{set} y puedes tener múltiples destinos:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{l+s+s1}{'foo'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{o}{=} \PYG{l+s+s1}{'foo'} \PYG{o}{\PYGZti{}} \PYG{l+s+s1}{'bar'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo}\PYG{o}{,} \PYG{n+nv}{bar} \PYG{o}{=} \PYG{l+s+s1}{'foo'}\PYG{o}{,} \PYG{l+s+s1}{'bar'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La etiqueta \code{set} también se puede usar ​​para ``capturar'' trozos de texto:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{foo} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{  \textless{}div id="pagination"\textgreater{}}
\PYG{x}{    ...}
\PYG{x}{  \textless{}/div\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endset} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{caution}{Prudencia:}
Si habilitas el escape automático, \emph{Twig} sólo tendrá en cuenta el contenido seguro al capturar fragmentos de texto.
\end{notice}


\chapter{\texttt{extends}}
\label{tags/extends:extends}\label{tags/extends::doc}
Puedes utilizar la etiqueta \code{extends} para extender una plantilla a partir de otra.

\begin{notice}{note}{Nota:}
Al igual que \emph{PHP}, \emph{Twig} no admite la herencia múltiple. Por lo tanto sólo puedes tener una etiqueta \code{extends} por reproducción. Sin embargo, \emph{Twig} apoya el {\hyperref[tags/use::doc]{\emph{reuso}}} (\autopageref*{tags/use::doc}) horizontal.
\end{notice}

Vamos a definir una plantilla base, \code{base.html}, la cual define el esqueleto de un documento \emph{HTML} simple:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}!DOCTYPE html\textgreater{}}
\PYG{n+nt}{\textless{}html}\PYG{n+nt}{\textgreater{}}
    \PYG{n+nt}{\textless{}head}\PYG{n+nt}{\textgreater{}}
        \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{head} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
            \PYG{n+nt}{\textless{}link} \PYG{n+na}{rel=}\PYG{l+s}{"stylesheet"} \PYG{n+na}{href=}\PYG{l+s}{"style.css"} \PYG{n+nt}{/\textgreater{}}
            \PYG{n+nt}{\textless{}title}\PYG{n+nt}{\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}} - My Webpage\PYG{n+nt}{\textless{}/title\textgreater{}}
        \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
    \PYG{n+nt}{\textless{}/head\textgreater{}}
    \PYG{n+nt}{\textless{}body}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}div} \PYG{n+na}{id=}\PYG{l+s}{"content"}\PYG{n+nt}{\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{n+nt}{\textless{}/div\textgreater{}}
        \PYG{n+nt}{\textless{}div} \PYG{n+na}{id=}\PYG{l+s}{"footer"}\PYG{n+nt}{\textgreater{}}
            \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{footer} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
                \PYG{n+ni}{\&copy;} Copyright 2011 by \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"http://dominio.invalido/"}\PYG{n+nt}{\textgreater{}}
                                             tú
                                         \PYG{n+nt}{\textless{}/a\textgreater{}}.
            \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
        \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}/body\textgreater{}}
\PYG{n+nt}{\textless{}/html\textgreater{}}
\end{Verbatim}

En este ejemplo, las etiquetas {\hyperref[tags/block::doc]{\emph{block}}} (\autopageref*{tags/block::doc}) definen cuatro bloques que las plantillas descendientes pueden rellenar. Todas las etiquetas \code{block} le dicen al motor de plantillas que una plantilla derivada puede sustituir esas porciones de la plantilla.


\section{Plantilla descendiente}
\label{tags/extends:plantilla-descendiente}
Una plantilla hija podría tener este aspecto:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{x}{Index}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{head} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{parent}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{    \textless{}style type="text/css"\textgreater{}}
\PYG{x}{        .important }\PYG{x}{\PYGZob{}}\PYG{x}{ color: \PYGZsh{}336699; \PYGZcb{}}
\PYG{x}{    \textless{}/style\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}h1\textgreater{}Index\textless{}/h1\textgreater{}}
\PYG{x}{    \textless{}p class="important"\textgreater{}}
\PYG{x}{        Welcome on my awesome homepage.}
\PYG{x}{    \textless{}/p\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Aquí, la clave es la etiqueta \code{extends}. Esta le dice al motor de plantillas que esta plantilla ``extiende'' otra plantilla. Cuando el sistema de plantillas evalúa esta plantilla, en primer lugar busca la plantilla padre. La etiqueta \code{extends} debe ser la primera etiqueta en la plantilla.

Ten en cuenta que debido a que la plantilla heredera no define el bloque \code{footer}, en su lugar se utiliza el valor de la plantilla padre.

No puedes definir múltiples etiquetas \code{block} con el mismo nombre en la misma plantilla. Esta limitación existe porque una etiqueta de bloque trabaja en ``ambas'' direcciones. Es decir, una etiqueta de bloque no sólo proporciona un hueco para rellenar --- sino que también define en el \emph{padre} el contenido que rellena el hueco. Si en una plantilla hubiera dos etiquetas \code{block} con nombres similares, la plantilla padre, no sabría cual contenido de entre esos bloques usar.

No obstante, si deseas imprimir un bloque varias veces, puedes utilizar la función \code{block()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}title\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{x}{\textless{}/title\textgreater{}}
\PYG{x}{\textless{}h1\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nb}{block}\PYG{o}{(}\PYG{l+s+s1}{'title'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/h1\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{body} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\subsection{Bloques padre}
\label{tags/extends:bloques-padre}
Es posible reproducir el contenido del bloque padre usando la función {\hyperref[functions/parent::doc]{\emph{parent}}} (\autopageref*{functions/parent::doc}). Esta devuelve el resultado del bloque padre:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}h3\textgreater{}Table Of Contents\textless{}/h3\textgreater{}}
\PYG{x}{    ...}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{parent}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\subsection{Etiquetas de cierre de bloque nombradas}
\label{tags/extends:etiquetas-de-cierre-de-bloque-nombradas}
\emph{Twig} te permite poner el nombre del bloque después de la etiqueta para facilitar su lectura:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{inner\PYGZus{}sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        ...}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{n+nv}{inner\PYGZus{}sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Por supuesto, el nombre después de la palabra \code{endblock} debe coincidir con el nombre del bloque.


\subsection{Bloques anidados y ámbito}
\label{tags/extends:bloques-anidados-y-ambito}
Los bloques se pueden anidar para diseños más complejos. Por omisión, los bloques tienen acceso a las variables del ámbito externo:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{item} \PYG{k}{in} \PYG{n+nv}{seq} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}li\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{loop\PYGZus{}item} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{item} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{x}{\textless{}/li\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\subsection{Atajos de bloque}
\label{tags/extends:atajos-de-bloque}
Para bloques con poco contenido, es posible utilizar una sintaxis abreviada. Las siguientes construcciones hacen exactamente lo mismo:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{page\PYGZus{}title}\PYG{o}{\textbar{}}\PYG{n+nf}{title} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{n+nv}{page\PYGZus{}title}\PYG{o}{\textbar{}}\PYG{n+nf}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\subsection{Herencia dinámica}
\label{tags/extends:herencia-dinamica}
\emph{Twig} es compatible con la herencia dinámica usando una variable como la plantilla base:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{n+nv}{alguna\PYGZus{}var} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Si la variable se evalúa como un objeto \code{Twig\_Template}, \emph{Twig} la utilizará como la plantilla padre:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// \PYGZob{}\PYGZpc{} extends base \PYGZpc{}\PYGZcb{}}

\PYG{n+nv}{\PYGZdl{}base} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{loadTemplate}\PYG{p}{(}\PYG{l+s+s1}{'some\PYGZus{}layout\PYGZus{}template.twig'}\PYG{p}{);}

\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{display}\PYG{p}{(}\PYG{l+s+s1}{'template.twig'}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'base'} \PYG{o}{=\textgreater{}} \PYG{n+nv}{\PYGZdl{}base}\PYG{p}{));}
\end{Verbatim}
Nuevo en la versión 1.2: La posibilidad de pasar un arreglo de plantillas se añadió en \emph{Twig} 1.2.
También puedes proporcionar una lista de plantillas que comprueben su existencia. La primer plantilla existente se utilizará como el padre:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{o}{[}\PYG{l+s+s1}{'base.html'}\PYG{o}{,} \PYG{l+s+s1}{'base\PYGZus{}layout.html'}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\subsection{Herencia condicional}
\label{tags/extends:herencia-condicional}
Gracias a que el nombre para la plantilla padre puede ser cualquier expresión \emph{Twig}, es posible el mecanismo de herencia condicional:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{n+nv}{standalone} \PYG{p}{?} \PYG{l+s+s2}{"minimum.html"} \PYG{o}{:} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

En este ejemplo, la plantilla debe extender a la plantilla base ``minimum.html'' si la variable \code{standalone} evalúa a \code{true}, o de otra manera extiende a ``base.html''.


\strong{Ver También:}


{\hyperref[functions/block::doc]{\emph{block}}} (\autopageref*{functions/block::doc}), {\hyperref[tags/block::doc]{\emph{block}}} (\autopageref*{tags/block::doc}), {\hyperref[functions/parent::doc]{\emph{parent}}} (\autopageref*{functions/parent::doc}), {\hyperref[tags/use::doc]{\emph{use}}} (\autopageref*{tags/use::doc})




\chapter{\texttt{block}}
\label{tags/block::doc}\label{tags/block:block}
Los bloques se utilizan para la herencia y actúan como marcadores de posición y reemplazo al mismo tiempo. Estos están documentados en detalle en la documentación de la etiqueta {\hyperref[tags/extends::doc]{\emph{extends}}} (\autopageref*{tags/extends::doc}).

Los nombres de bloque deben consistir de caracteres alfanuméricos y guiones bajos. Los guiones no están permitidos.


\strong{Ver También:}


{\hyperref[functions/block::doc]{\emph{block}}} (\autopageref*{functions/block::doc}), {\hyperref[functions/parent::doc]{\emph{parent}}} (\autopageref*{functions/parent::doc}), {\hyperref[tags/use::doc]{\emph{use}}} (\autopageref*{tags/use::doc}), {\hyperref[tags/extends::doc]{\emph{extends}}} (\autopageref*{tags/extends::doc})




\chapter{\texttt{include}}
\label{tags/include:include}\label{tags/include::doc}
La declaración \code{include} inserta una plantilla y devuelve el contenido presentado por ese archivo en el espacio de nombres actual:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'header.html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    Body}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'footer.html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Las plantillas incluidas tienen acceso a las variables del contexto activo.

Si estás utilizando el cargador del sistema de archivos, las plantillas se buscan en la ruta definida por este.

Puedes añadir variables adicionales pasándolas después de la palabra clave \code{with}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} la plantilla foo tendrá acceso a las variables del contexto}
\PYG{c}{   actual y al de foo \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'foo'} \PYG{k}{with} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{vars} \PYG{o}{=} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'foo'} \PYG{k}{with} \PYG{n+nv}{vars} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Puedes desactivar el acceso al contexto añadiendo la palabra clave \code{only}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} únicamente la variable foo será accesible \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'foo'} \PYG{k}{with} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{n+nv}{only} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} ninguna variable será accesible \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'foo'} \PYG{n+nv}{only} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{tip}{Truco:}
Cuando incluyes una plantilla creada por un usuario final, debes considerar supervisarla. Más información en el capítulo {\hyperref[api::doc]{\emph{Twig para desarrolladores}}} (\autopageref*{api::doc}) y en la documentación de la {\hyperref[tags/sandbox::doc]{\emph{etiqueta sandbox}}} (\autopageref*{tags/sandbox::doc}).
\end{notice}

El nombre de la plantilla puede ser cualquier expresión \emph{Twig} válida:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{n+nv}{some\PYGZus{}var} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{n+nv}{ajax} \PYG{p}{?} \PYG{l+s+s1}{'ajax.html'} \PYG{o}{:} \PYG{l+s+s1}{'not\PYGZus{}ajax.html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Y si la expresión evalúa como un objeto \code{Twig\_Template}, \emph{Twig} la usará directamente:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// \PYGZob{}\PYGZpc{} include template \PYGZpc{}\PYGZcb{}}

\PYG{n+nv}{\PYGZdl{}template} \PYG{o}{=} \PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{loadTemplate}\PYG{p}{(}\PYG{l+s+s1}{'some\PYGZus{}template.twig'}\PYG{p}{);}

\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{loadTemplate}\PYG{p}{(}\PYG{l+s+s1}{'template.twig'}\PYG{p}{)}
     \PYG{o}{-\textgreater{}}\PYG{n+na}{display}\PYG{p}{(}\PYG{k}{array}\PYG{p}{(}\PYG{l+s+s1}{'template'} \PYG{o}{=\textgreater{}} \PYG{n+nv}{\PYGZdl{}template}\PYG{p}{));}
\end{Verbatim}
Nuevo en la versión 1.2: La característica \code{ignore missing} se añadió en \emph{Twig} 1.2.
Puedes marcar un \code{include} con \code{ignore missing} en cuyo caso \emph{Twig} omitirá la declaración si la plantilla a ignorar no existe. Se tiene que colocar justo después del nombre de la plantilla. He aquí algunos ejemplos válidos:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s2}{"sidebar.html"} \PYG{k}{ignore missing} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s2}{"sidebar.html"} \PYG{k}{ignore missing} \PYG{k}{with} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{p}{'}\PYG{n+nv}{bar}\PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s2}{"sidebar.html"} \PYG{k}{ignore missing} \PYG{n+nv}{only} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}
Nuevo en la versión 1.2: La posibilidad de pasar un arreglo de plantillas se añadió en \emph{Twig} 1.2.
También puedes proporcionar una lista de plantillas para comprobar su existencia antes de la inclusión. La primer plantilla existente será incluida:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{o}{[}\PYG{l+s+s1}{'page\PYGZus{}detailed.html'}\PYG{o}{,} \PYG{l+s+s1}{'page.html'}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Si se le da \code{ignore missing}, caerá de nuevo en reproducir nada si ninguna de las plantillas existe, de lo contrario se producirá una excepción.


\chapter{\texttt{import}}
\label{tags/import:import}\label{tags/import::doc}
\emph{Twig} apoya poner en macros el código usado frecuentemente {\hyperref[tags/macro::doc]{\emph{macros}}} (\autopageref*{tags/macro::doc}). Estas macros pueden estar en diferentes plantillas y se importan desde allí.

Hay dos formas de importar plantillas. Puedes importar la plantilla completa en una variable o solicitar macros específicas de ella.

Imaginemos que tienes un módulo auxiliar que reproduce formularios (llamado \code{formularios.html}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{macro} \PYG{n+nv}{input}\PYG{o}{(}\PYG{n+nv}{name}\PYG{o}{,} \PYG{n+nv}{value}\PYG{o}{,} \PYG{n+nv}{type}\PYG{o}{,} \PYG{n+nv}{size}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}input type="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{type}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'text'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             name="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{name} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             value="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{value}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{             size="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{size}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+m}{2}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{" /\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endmacro} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{macro} \PYG{n+nv}{textarea}\PYG{o}{(}\PYG{n+nv}{name}\PYG{o}{,} \PYG{n+nv}{value}\PYG{o}{,} \PYG{n+nv}{rows}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}textarea name="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{name} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{          rows="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{rows}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+m}{1}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{          cols="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{cols}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+m}{4}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"\textgreater{}}
\PYG{x}{          }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{value}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{\textless{}/textarea\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endmacro} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La forma más fácil y flexible es importar todo el módulo en una variable.
De esa manera puedes acceder a los atributos:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{import} \PYG{l+s+s1}{'formularios.html'} \PYG{k}{as} \PYG{n+nv}{forms} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{x}{\textless{}dl\textgreater{}}
\PYG{x}{    \textless{}dt\textgreater{}Username\textless{}/dt\textgreater{}}
\PYG{x}{    \textless{}dd\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{forms}\PYG{n+nv}{.input}\PYG{o}{(}\PYG{l+s+s1}{'username'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/dd\textgreater{}}
\PYG{x}{    \textless{}dt\textgreater{}Password\textless{}/dt\textgreater{}}
\PYG{x}{    \textless{}dd\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{forms}\PYG{n+nv}{.input}\PYG{o}{(}\PYG{l+s+s1}{'password'}\PYG{o}{,} \PYG{n+nv}{null}\PYG{o}{,} \PYG{l+s+s1}{'password'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/dd\textgreater{}}
\PYG{x}{\textless{}/dl\textgreater{}}
\PYG{x}{\textless{}p\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{forms}\PYG{n+nv}{.textarea}\PYG{o}{(}\PYG{l+s+s1}{'comentario'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/p\textgreater{}}
\end{Verbatim}

Alternativamente, puedes importar nombres desde la plantilla al espacio de nombres actual:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{from} \PYG{l+s+s1}{'formularios.html'} \PYG{k}{import} \PYG{n+nv}{input} \PYG{k}{as} \PYG{n+nv}{campo\PYGZus{}input}\PYG{o}{,} \PYG{n+nv}{textarea} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{x}{\textless{}dl\textgreater{}}
\PYG{x}{    \textless{}dt\textgreater{}Username\textless{}/dt\textgreater{}}
\PYG{x}{    \textless{}dd\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{input\PYGZus{}field}\PYG{o}{(}\PYG{l+s+s1}{'username'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/dd\textgreater{}}
\PYG{x}{    \textless{}dt\textgreater{}Password\textless{}/dt\textgreater{}}
\PYG{x}{    \textless{}dd\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{input\PYGZus{}field}\PYG{o}{(}\PYG{l+s+s1}{'password'}\PYG{o}{,} \PYG{l+s+s1}{''}\PYG{o}{,} \PYG{l+s+s1}{'password'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/dd\textgreater{}}
\PYG{x}{\textless{}/dl\textgreater{}}
\PYG{x}{\textless{}p\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{textarea}\PYG{o}{(}\PYG{l+s+s1}{'comment'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/p\textgreater{}}
\end{Verbatim}

La importación no es necesaria si las macros y la plantilla están definidas en el mismo archivo; en su lugar usa la variable especial \code{\_self}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}\# plantilla index.html \#\PYGZcb{}

\PYGZob{}\% macro textarea(name, value, rows) \%\PYGZcb{}
    \textless{}textarea name="\PYGZob{}\PYGZob{} name \PYGZcb{}\PYGZcb{}"
          rows="\PYGZob{}\PYGZob{} rows\textbar{}default(10) \PYGZcb{}\PYGZcb{}"
          cols="\PYGZob{}\PYGZob{} cols\textbar{}default(40) \PYGZcb{}\PYGZcb{}"\textgreater{}
          \PYGZob{}\PYGZob{} value\textbar{}e \PYGZcb{}\PYGZcb{}
\textless{}/textarea\textgreater{}
\PYGZob{}\% endmacro \%\PYGZcb{}

\textless{}p\textgreater{}\PYGZob{}\PYGZob{} \_self.textarea('comentario') \PYGZcb{}\PYGZcb{}\textless{}/p\textgreater{}
\end{Verbatim}

Pero sí puedes crear un alias importando la variable \code{\_self}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} plantilla index.html \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{macro} \PYG{n+nv}{textarea}\PYG{o}{(}\PYG{n+nv}{name}\PYG{o}{,} \PYG{n+nv}{value}\PYG{o}{,} \PYG{n+nv}{rows}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}textarea name="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{name} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{          rows="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{rows}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+m}{1}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"}
\PYG{x}{          cols="}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{cols}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+m}{4}\PYG{l+m}{0}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{"\textgreater{}}
\PYG{x}{          }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{value}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{\textless{}/textarea\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endmacro} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{import} \PYG{p}{\PYGZus{}}\PYG{n+nv}{self} \PYG{k}{as} \PYG{n+nv}{forms} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{x}{\textless{}p\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{forms}\PYG{n+nv}{.textarea}\PYG{o}{(}\PYG{l+s+s1}{'comentario'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/p\textgreater{}}
\end{Verbatim}


\strong{Ver También:}


{\hyperref[tags/macro::doc]{\emph{macro}}} (\autopageref*{tags/macro::doc}), {\hyperref[tags/from::doc]{\emph{from}}} (\autopageref*{tags/from::doc})




\chapter{\texttt{from}}
\label{tags/from:from}\label{tags/from::doc}
Las etiquetas \code{from} importan nombres de {\hyperref[tags/macro::doc]{\emph{macro}}} (\autopageref*{tags/macro::doc}) al espacio de nombres actual. La etiqueta está documentada en detalle en la documentación de la etiqueta {\hyperref[tags/import::doc]{\emph{import}}} (\autopageref*{tags/import::doc}).


\strong{Ver También:}


{\hyperref[tags/macro::doc]{\emph{macro}}} (\autopageref*{tags/macro::doc}), {\hyperref[tags/import::doc]{\emph{import}}} (\autopageref*{tags/import::doc})




\chapter{\texttt{use}}
\label{tags/use:use}\label{tags/use::doc}Nuevo en la versión 1.1: La reutilización horizontal se añadió en \emph{Twig} 1.1.
\begin{notice}{note}{Nota:}
La reutilización horizontal es una característica avanzada de \emph{Twig} que casi nunca es necesaria en plantillas regulares. La utilizan principalmente proyectos que tienen que reutilizar bloques de plantilla sin utilizar herencia.
\end{notice}

La herencia de plantillas es una de las más poderosas características de \emph{Twig}, pero está limitada a herencia simple; una plantilla sólo puede extender a una plantilla más.
Esta limitación facilita el entendimiento y depuración de la herencia de plantillas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La reutilización horizontal es una forma de conseguir el mismo objetivo que la herencia múltiple, pero sin la complejidad asociada:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{use} \PYG{l+s+s2}{"bloques.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La declaración \code{use} dice a \emph{Twig} que importe los bloques definidos en \code{bloques.html} a la plantilla actual (es como las macros, pero para bloques):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} bloques.html \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

En este ejemplo, la declaración \code{use} importa la declaración del bloque \code{sidebar} en la plantilla principal. El código ---en su mayoría--- es equivalente a lo siguiente (los bloques importados no se generan automáticamente):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}\begin{quote}

La etiqueta \code{use} sólo importa una plantilla si esta:
\end{quote}
\begin{itemize}
\item {} 
no extiende a otra plantilla

\item {} 
no define macros, y

\item {} 
si el cuerpo está vacío. Pero puedes \emph{usar} otras plantillas.

\end{itemize}
\end{notice}

\begin{notice}{note}{Nota:}
Debido a que las declaraciones \code{use} se resuelven independientemente del contexto pasado a la plantilla, la referencia de la plantilla no puede ser una expresión.
\end{notice}

La plantilla principal también puede sustituir cualquier bloque importado. Si la plantilla ya define el bloque \code{sidebar}, entonces, se ignora el definido en \code{bloques.html}. Para evitar conflictos de nombre, puedes cambiar el nombre de los bloques importados:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{use} \PYG{l+s+s2}{"bloques.html"} \PYG{k}{with} \PYG{n+nv}{sidebar} \PYG{k}{as} \PYG{n+nv}{base\PYGZus{}sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}
Nuevo en la versión 1.3: El apoyo a \code{parent()} se añadió en \emph{Twig 1.3}.
La función \code{parent()} determina automáticamente el árbol de herencia correcto, por lo tanto lo puedes utilizar cuando reemplaces un bloque definido en una plantilla importada:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{use} \PYG{l+s+s2}{"bloques.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{parent}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

En este ejemplo, el \code{parent()} correctamente llama al bloque \code{sidebar} de la plantilla \code{blocks.html}.

\begin{notice}{tip}{Truco:}
En \emph{Twig 1.2}, el cambio de nombre te permite simular la herencia llamando al bloque ``padre'':

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{use} \PYG{l+s+s2}{"bloques.html"} \PYG{k}{with} \PYG{n+nv}{sidebar} \PYG{k}{as} \PYG{n+nv}{parent\PYGZus{}sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nb}{block}\PYG{o}{(}\PYG{l+s+s1}{'parent\PYGZus{}sidebar'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}
\end{notice}

\begin{notice}{note}{Nota:}
Puedes utilizar tantas instrucciones \code{use} como quieras en cualquier plantilla determinada.
Si dos plantillas importadas definen el mismo bloque, la última gana.
\end{notice}


\chapter{\texttt{spaceless}}
\label{tags/spaceless:spaceless}\label{tags/spaceless::doc}
Usa la etiqueta \code{spaceless} para eliminar espacios en blanco \emph{entre las etiquetas HTML}, no espacios en blanco en las etiquetas \emph{HTML} o en el texto simple:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{spaceless} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}div\textgreater{}}
\PYG{x}{        \textless{}strong\textgreater{}foo\textless{}/strong\textgreater{}}
\PYG{x}{    \textless{}/div\textgreater{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endspaceless} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} Producirá \textless{}div\textgreater{}\textless{}strong\textgreater{}foo\textless{}/strong\textgreater{}\textless{}/div\textgreater{} \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Esta etiqueta no tiene la intención de ``optimizar'' el tamaño del contenido \emph{HTML} generado, sino simplemente eliminar espacios en blanco extra entre las etiquetas \emph{HTML} para evitar la representación caprichosa en navegadores bajo algunas circunstancias.

\begin{notice}{tip}{Truco:}
Si deseas optimizar el tamaño del contenido \emph{HTML} generado, en su lugar comprime el resultado con \code{gzip}.
\end{notice}

\begin{notice}{tip}{Truco:}
Si deseas crear una etiqueta que retire todos los espacios en blanco extra en una cadena \emph{HTML}, te advertimos que esto no es tan fácil como parece (piensa en etiquetas \code{textarea} o \code{pre}, por ejemplo). Usar una biblioteca de terceros, como \code{Tidy} probablemente es una mejor idea.
\end{notice}

\begin{notice}{tip}{Truco:}
Para más información sobre el control de los espacios en blanco, lee la {\hyperref[templates::doc]{\emph{sección dedicada}}} (\autopageref*{templates::doc}) de la documentación y también aprende cómo puedes utilizar el modificador del control de espacios en blanco en tus etiquetas.
\end{notice}


\chapter{\texttt{autoescape}}
\label{tags/autoescape:autoescape}\label{tags/autoescape::doc}
Ya sea que el escape automático esté habilitado o no, puedes marcar una sección de una plantilla para que sea escapada o no utilizando la etiqueta \code{autoescape}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} La siguiente sintaxis trabaja desde Twig 1.8 -- ve abajo las notas para las versiones anteriores \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    En este bloque, todo se escapará automáticamente}
\PYG{x}{    usando la estrategia HTML}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{l+s+s1}{'html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    En este bloque, todo se escapará automáticamente}
\PYG{x}{    usando la estrategia HTML}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{l+s+s1}{'js'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    Todo en este bloque se escapará automáticamente con la estrategia}
\PYG{x}{    de escape js}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{k+kp}{false} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    En este bloque, todo se emitirá tal cual}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Antes de \emph{Twig 1.8}, la sintaxis era distinta:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{k+kp}{true} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    En este bloque, todo se escapará automáticamente}
\PYG{x}{    usando la estrategia HTML}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{k+kp}{false} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    En este bloque, todo se emitirá tal cual}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{k+kp}{true} \PYG{n+nv}{js} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    Todo en este bloque se escapará automáticamente usando}
\PYG{x}{    la estrategia de escape js}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}
\end{notice}

Cuando se activa el escape automático, de manera predeterminada todo será escapado, salvo los valores marcados explícitamente como seguros. Estos se pueden marcar en la plantilla usando el filtro {\hyperref[filters/raw::doc]{\emph{raw}}} (\autopageref*{filters/raw::doc}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{safe\PYGZus{}value}\PYG{o}{\textbar{}}\PYG{n+nf}{raw} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Las funciones que devuelven datos de la plantilla (como {\hyperref[tags/macro::doc]{\emph{macros}}} (\autopageref*{tags/macro::doc}) y {\hyperref[functions/parent::doc]{\emph{parent}}} (\autopageref*{functions/parent::doc})) siempre devuelven marcado seguro.

\begin{notice}{note}{Nota:}
\emph{Twig} es lo suficientemente inteligente como para no escapar un valor que ya fue escapado por el filtro {\hyperref[filters/escape::doc]{\emph{escape}}} (\autopageref*{filters/escape::doc}).
\end{notice}

\begin{notice}{note}{Nota:}
El capítulo {\hyperref[api::doc]{\emph{Twig para desarrolladores}}} (\autopageref*{api::doc}) proporciona más información acerca de cuándo y cómo se aplica el escape automático.
\end{notice}


\chapter{\texttt{raw}}
\label{tags/raw:raw}\label{tags/raw::doc}
La etiqueta \code{raw} marca secciones como texto seguro que no se deben analizar.
Por ejemplo, para reproducir un segmento de la sintaxis de \emph{Twig} en una plantilla, puedes utilizar este fragmento:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{raw} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
    \textless{}ul\textgreater{}
    \PYGZob{}\PYGZpc{} for item in seq \PYGZpc{}\PYGZcb{}
        \textless{}li\textgreater{}\PYGZob{}\PYGZob{} item \PYGZcb{}\PYGZcb{}\textless{}/li\textgreater{}
    \PYGZob{}\PYGZpc{} endfor \PYGZpc{}\PYGZcb{}
    \textless{}/ul\textgreater{}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endraw} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{flush}}
\label{tags/flush::doc}\label{tags/flush:flush}Nuevo en la versión 1.5: La etiqueta \code{flush} se añadió en \emph{Twig} 1.5.
La etiqueta \code{flush} le dice a \emph{Twig} que vacíe el contenido de la memoria intermedia:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{flush} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Internamente, \emph{Twig} usa la función \href{http://php.net/flush}{flush} de \emph{PHP}.
\end{notice}


\chapter{\texttt{do}}
\label{tags/do:do}\label{tags/do::doc}\label{tags/do:id1}Nuevo en la versión 1.5: La etiqueta \code{do} se agregó en \emph{Twig} 1.5.
La etiqueta \code{do} trabaja exactamente como la variable expresión regular (\code{\{\{ ... \}\}}) solo que no imprime nada:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{do} \PYG{l+m}{1} \PYG{o}{+} \PYG{l+m}{2} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{sandbox}}
\label{tags/sandbox:sandbox}\label{tags/sandbox::doc}
La etiqueta \code{sandbox} se puede utilizar para activar el modo de recinto de seguridad para una plantilla incluida, cuando no está habilitado globalmente el modo de recinto de seguridad para el entorno \emph{Twig}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{sandbox} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{include} \PYG{l+s+s1}{'user.html'} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endsandbox} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{warning}{Advertencia:}
La etiqueta \code{sandbox} sólo está disponible cuando está habilitada la extensión \code{sandbox} (ve el capítulo {\hyperref[api::doc]{\emph{Twig para desarrolladores}}} (\autopageref*{api::doc})).
\end{notice}

\begin{notice}{note}{Nota:}
La etiqueta \code{sandboc} sólo se puede utilizar para asegurar una etiqueta \code{include} y no se puede utilizar para proteger una sección de una plantilla. Por ejemplo, el siguiente ejemplo no funcionará:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{sandbox} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{l+m}{1.}\PYG{n+nv}{.2} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{i} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endsandbox} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}
\end{notice}


\chapter{\texttt{embed}}
\label{tags/embed:embed}\label{tags/embed::doc}Nuevo en la versión 1.8: La etiqueta \code{embed} se añadió en \emph{Twig 1.8}.
La etiqueta \code{embed} combina el comportamiento de {\hyperref[tags/include::doc]{\emph{include}}} (\autopageref*{tags/include::doc}) y
{\hyperref[tags/extends::doc]{\emph{extends}}} (\autopageref*{tags/extends::doc}).
Esta te permite incluir contenido de otras plantillas, tal cómo lo hace \code{include}. Pero también te permite reemplazar cualquier bloque definido en la
plantilla incluida, como cuando extiendes una plantilla.

Piensa en una plantilla integrada como un esqueleto del ``microdiseño''.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{embed} \PYG{l+s+s2}{"esqueleto\PYGZus{}tentativo.twig"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} Estos bloques están definidos en "esqueleto\PYGZus{}tentativo.twig" \PYGZsh{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} Y los sustituimos aquí:                    \PYGZsh{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{left\PYGZus{}teaser} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        Algún contenido para la caja de prueba izquierda}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{right\PYGZus{}teaser} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        Algún contenido para la caja de prueba derecha}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endembed} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La etiqueta \code{embed} lleva la idea de la herencia de plantillas a nivel de
fragmentos de contenido. Si bien la herencia de plantillas posibilita los ``esqueletos de documento'',
que están llenos de vida por las plantillas hijas, la etiqueta \code{embed} te permite crear ``esqueletos'' para las más pequeñas unidades de contenido y reutilizarlas y llenarlas en cualquier lugar que quieras.

Debido al caso de uso puede no ser tan obvio, veamos un ejemplo simplificado.
Imagina una plantilla base compartida por varias páginas \emph{HTML}, la cual define un solo bloque llamado ``contenido'':

\begin{Verbatim}[commandchars=\\\{\}]
┌--- diseño de página ----------------┐
\textbar{}                                     \textbar{}
\textbar{}        ┌-- bloque "contenido" --┐   \textbar{}
\textbar{}        \textbar{}                        \textbar{}   \textbar{}
\textbar{}        \textbar{}                        \textbar{}   \textbar{}
\textbar{}        \textbar{} (plantilla hija aquí   \textbar{}   \textbar{}
\textbar{}        \textbar{}  lleva el contenido)   \textbar{}   \textbar{}
\textbar{}        \textbar{}                        \textbar{}   \textbar{}
\textbar{}        \textbar{}                        \textbar{}   \textbar{}
\textbar{}        └------------------------┘   \textbar{}
\textbar{}                                     \textbar{}
└-------------------------------------┘
\end{Verbatim}

Algunas páginas (``foo'' y ``bar'') comparten la misma estructura del contenido ---
dos cajas apiladas verticalmente:

\begin{Verbatim}[commandchars=\\\{\}]
┌--- diseño de página ----------------┐
\textbar{}                                     \textbar{}
\textbar{}        ┌-- bloque "contenido" --┐   \textbar{}
\textbar{}        \textbar{} ┌- bloque "sup" -----┐ \textbar{}   \textbar{}
\textbar{}        \textbar{} \textbar{}                    \textbar{} \textbar{}   \textbar{}
\textbar{}        \textbar{} └--------------------┘ \textbar{}   \textbar{}
\textbar{}        \textbar{} ┌- bloque "inf" -----┐ \textbar{}   \textbar{}
\textbar{}        \textbar{} \textbar{}                    \textbar{} \textbar{}   \textbar{}
\textbar{}        \textbar{} └--------------------┘ \textbar{}   \textbar{}
\textbar{}        └------------------------┘   \textbar{}
\textbar{}                                     \textbar{}
└-------------------------------------┘
\end{Verbatim}

mientras otras páginas (``boom'' y ``baz'') comparten una estructura de contenido diferente --- dos cajas lado a lado:

\begin{Verbatim}[commandchars=\\\{\}]
┌--- diseño de página ----------------┐
\textbar{}                                     \textbar{}
\textbar{}        ┌-- bloque "contenido" --┐   \textbar{}
\textbar{}        \textbar{}                        \textbar{}   \textbar{}
\textbar{}        \textbar{} ┌ bloque ┐ ┌ bloque ┐  \textbar{}   \textbar{}
\textbar{}        \textbar{} \textbar{} "izq"  \textbar{} \textbar{} "der"  \textbar{}  \textbar{}   \textbar{}
\textbar{}        \textbar{} \textbar{}        \textbar{} \textbar{}        \textbar{}  \textbar{}   \textbar{}
\textbar{}        \textbar{} \textbar{}        \textbar{} \textbar{}        \textbar{}  \textbar{}   \textbar{}
\textbar{}        \textbar{} └--------┘ └--------┘  \textbar{}   \textbar{}
\textbar{}        └------------------------┘   \textbar{}
\textbar{}                                     \textbar{}
└-------------------------------------┘
\end{Verbatim}

Sin la etiqueta \code{embed}, tienes dos maneras de diseñar tus plantillas:
\begin{itemize}
\item {} 
Crear dos plantillas base ``intermedias'' que extiendan a la plantilla del diseño principal: una con cajas apiladas verticalmente usada por las páginas ``foo'' y ``bar'' y otra con cajas lado a lado para las páginas ``boom'' y ``baz''.

\item {} 
Integrar el marcado para las cajas sup/inf e izq/der en cada plantilla de página directamente.

\end{itemize}

Estas dos soluciones no se adaptan bien porque cada una tiene un gran inconveniente:
\begin{itemize}
\item {} 
La primer solución en verdad puede trabajar para este ejemplo simplificado. Pero imagina que añadimos una barra lateral, la cual a su vez contiene diferentes, estructuras de contenido recurrente. Ahora tendríamos que crear plantillas base intermedias para todas las combinaciones que produzcan estructuras de contenido y estructura de la barra lateral... y así sucesivamente.

\item {} 
La segunda solución consiste en duplicar código común con todos sus efectos y consecuencias negativas: cualquier cambio implica encontrar y editar todas las copias afectadas por la estructura, la corrección se tiene que verificar en cada copia, las copias pueden estar fuera de sincronía por modificaciones descuidadas, etc.

\end{itemize}

En tal situación, la etiqueta \code{embed} viene muy bien. El código del diseño común puede vivir en una sola plantilla base, y las dos estructuras de contenido diferentes, vamos a llamarlas ``microdiseños'' tendremos plantillas separadas, que serán integradas conforme sea necesario:

Plantilla de la página \code{foo.twig}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"layout\PYGZus{}skeleton.twig"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{content} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{embed} \PYG{l+s+s2}{"vertical\PYGZus{}boxes\PYGZus{}skeleton.twig"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{top} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{            Algún contenido para la caja de prueba superior}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{bottom} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{            Algún contenido para la caja de prueba inferior}
\PYG{x}{        }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endembed} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Y aquí está el código para \code{vertical\_boxes\_skeleton.twig}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\textless{}div} \PYG{n+na}{class=}\PYG{l+s}{"top\PYGZus{}box"}\PYG{n+nt}{\textgreater{}}
    \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{top} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
        Contenido predefinido para la caja superior
    \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{n+nt}{\textless{}/div\textgreater{}}

\PYG{n+nt}{\textless{}div} \PYG{n+na}{class=}\PYG{l+s}{"bottom\PYGZus{}box"}\PYG{n+nt}{\textgreater{}}
    \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{bottom} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
        Contenido predefinido para la caja inferior
    \PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{n+nt}{\textless{}/div\textgreater{}}
\end{Verbatim}

El objetivo de la plantilla \code{vertical\_boxes\_skeleton.twig} es el de eliminar el marcado \emph{HTML} para las cajas.

La etiqueta \code{embed} toma exactamente los mismos argumentos que la etiqueta \code{include}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{embed} \PYG{l+s+s2}{"base"} \PYG{k}{with} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endembed} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{embed} \PYG{l+s+s2}{"base"} \PYG{k}{with} \PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'foo'}\PYG{o}{:} \PYG{l+s+s1}{'bar'}\PYG{o}{\PYGZcb{}} \PYG{n+nv}{only} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endembed} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{embed} \PYG{l+s+s2}{"base"} \PYG{k}{ignore missing} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endembed} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{warning}{Advertencia:}
Debido a que las plantillas integradas no tienen ``nombres'', las estrategias de autoescape basadas en el \code{"nombre de archivo"} de la plantilla no funcionan como se espera si cambias el contexto (por ejemplo, si integras una plantilla \emph{CSS}/\emph{JavaScript} en un archivo \emph{HTML}). En ese caso, establece explícitamente el valor predefinido para la estrategia de escape automático con la etiqueta \code{autoescape}.
\end{notice}


\strong{Ver También:}


{\hyperref[tags/include::doc]{\emph{include}}} (\autopageref*{tags/include::doc})




\part{Filtros}
\label{filters/index::doc}\label{filters/index:filtros}

\chapter{\texttt{date}}
\label{filters/date:date}\label{filters/date::doc}Nuevo en la versión 1.1: La compatibilidad con la zona horaria se añadió en \emph{Twig} 1.1.Nuevo en la versión 1.5: La compatibilidad para el formato de fecha predefinido se añadió en \emph{Twig} 1.5.Nuevo en la versión 1.6.1: El soporte para la zona horaria predeterminada se añadió en \emph{Twig} 1.6.1
El filtro \code{date} es capaz de formatear una fecha con una forma suministrada explícitamente:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{post}\PYG{n+nv}{.published\PYGZus{}at}\PYG{o}{\textbar{}}\PYG{n+nf}{date}\PYG{o}{(}\PYG{l+s+s2}{"m/d/Y"}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

El filtro \code{date} acepta cadenas (estas deben ser compatibles con los formatos de la función \href{http://www.php.net/date}{date}) e instancias de \href{http://www.php.net/DateTime}{DateTime}, o instancias de \href{http://www.php.net/DateInterval}{DateInterval}. Por ejemplo, para mostrar la fecha actual, filtra la palabra \code{"now"}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"now"}\PYG{o}{\textbar{}}\PYG{n+nf}{date}\PYG{o}{(}\PYG{l+s+s2}{"m/d/Y"}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Para escapar palabras y caracteres en el formato de fecha usa \code{\textbackslash{}\textbackslash{}} al frente de cada carácter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{post}\PYG{n+nv}{.published\PYGZus{}at}\PYG{o}{\textbar{}}\PYG{n+nf}{date}\PYG{o}{(}\PYG{l+s+s2}{"F jS \PYGZbs{}\PYGZbs{}a\PYGZbs{}\PYGZbs{}t g:ia"}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

También puedes especificar una zona horaria:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{post}\PYG{n+nv}{.published\PYGZus{}at}\PYG{o}{\textbar{}}\PYG{n+nf}{date}\PYG{o}{(}\PYG{l+s+s2}{"m/d/Y"}\PYG{o}{,} \PYG{l+s+s2}{"Europe/Paris"}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Si no proporcionas un formato, \emph{Twig} utilizará el formato predefinido: \code{F j, Y H:i}. Puedes cambiar fácilmente el predefinido llamando al método \code{setDateFormat()} en la instancia de la extensión \code{core}. El primer argumento es el formato predefinido para fechas y el segundo es el formato predeterminado para los intervalos de fecha:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{getExtension}\PYG{p}{(}\PYG{l+s+s1}{'core'}\PYG{p}{)}\PYG{o}{-\textgreater{}}\PYG{n+na}{setDateFormat}\PYG{p}{(}\PYG{l+s+s1}{'d/m/Y'}\PYG{p}{,} \PYG{l+s+s1}{'\PYGZpc{}d days'}\PYG{p}{);}
\end{Verbatim}

Puedes fijar globalmente la zona horaria predefinida llamando a \code{setTimezone()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{getExtension}\PYG{p}{(}\PYG{l+s+s1}{'core'}\PYG{p}{)}\PYG{o}{-\textgreater{}}\PYG{n+na}{setTimezone}\PYG{p}{(}\PYG{l+s+s1}{'Europe/Paris'}\PYG{p}{);}
\end{Verbatim}

Si el valor pasado al filtro \code{date} es \code{null}, por omisión devolverá la fecha actual.
Si en lugar de la fecha actual quieres una cadena vacía, utiliza un operador ternario:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZob{} post.published\_at is empty ? "" : post.published\_at\textbar{}date("m/d/Y") \PYGZcb{}\PYGZcb{}
\end{Verbatim}


\chapter{\texttt{format}}
\label{filters/format::doc}\label{filters/format:format}
El filtro \code{format} filtra formatos de una cadena dada sustituyendo los marcadores de posición (los marcadores de posición siguen la notación de \code{printf}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"Me gustan \PYGZpc{}s y \PYGZpc{}s."}\PYG{o}{\textbar{}}\PYG{n+nf}{format}\PYG{o}{(}\PYG{n+nv}{foo}\PYG{o}{,} \PYG{l+s+s2}{"bar"}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} devuelve Me gustan foo y bar}
\PYG{c}{   si el parámetro foo es igual a la cadena foo. \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\strong{Ver También:}


{\hyperref[filters/replace::doc]{\emph{replace}}} (\autopageref*{filters/replace::doc})




\chapter{\texttt{replace}}
\label{filters/replace::doc}\label{filters/replace:replace}
El filtro \code{reemplaza} formatos de una cadena dada sustituyendo los marcadores de posición (los marcadores de posición son libres):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"Me gustan \PYGZpc{}this\PYGZpc{} y \PYGZpc{}that\PYGZpc{}."}\PYG{o}{\textbar{}}\PYG{n+nf}{replace}\PYG{o}{(}\PYG{o}{\PYGZob{}}\PYG{l+s+s1}{'\PYGZpc{}this\PYGZpc{}'}\PYG{o}{:} \PYG{n+nv}{foo}\PYG{o}{,}
                                         \PYG{l+s+s1}{'\PYGZpc{}that\PYGZpc{}'}\PYG{o}{:} \PYG{l+s+s2}{"bar"}\PYG{o}{\PYGZcb{}}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} devuelve Me gustan foo y bar}
\PYG{c}{   si el parámetro foo es igual a la cadena foo. \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\strong{Ver También:}


{\hyperref[filters/format::doc]{\emph{format}}} (\autopageref*{filters/format::doc})




\chapter{\texttt{number\_format}}
\label{filters/number_format:number-format}\label{filters/number_format::doc}Nuevo en la versión 1.5: El filtro \code{number\_format} se añadió en \emph{Twig} 1.5
El filtro \code{number\_format} formatea números.  Este es una envoltura en torno a la función \href{http://php.net/number\_format}{number\_format} de \emph{PHP}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+m}{2}\PYG{l+m}{0}\PYG{l+m}{0.35}\PYG{o}{\textbar{}}\PYG{n+nf}{number\PYGZus{}format} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Puedes controlar el número de decimales, punto decimal, y separador de miles utilizando los argumentos adicionales:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+m}{9}\PYG{l+m}{8}\PYG{l+m}{0}\PYG{l+m}{0.333}\PYG{o}{\textbar{}}\PYG{n+nf}{number\PYGZus{}format}\PYG{o}{(}\PYG{l+m}{2}\PYG{o}{,} \PYG{l+s+s1}{','}\PYG{o}{,} \PYG{l+s+s1}{'.'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Si no proporcionas opciones de formato entonces \emph{Twig} usará las opciones de formato predefinidas:
\begin{itemize}
\item {} 
0 lugares decimales.

\item {} 
\code{.} como el punto decimal.

\item {} 
\code{,} como el separador de miles.

\end{itemize}

Estas opciones predefinidas se pueden cambiar fácilmente a través de la extensión del núcleo:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{getExtension}\PYG{p}{(}\PYG{l+s+s1}{'core'}\PYG{p}{)}\PYG{o}{-\textgreater{}}\PYG{n+na}{setNumberFormat}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{','}\PYG{p}{,} \PYG{l+s+s1}{'.'}\PYG{p}{);}
\end{Verbatim}

Puedes ajustar las opciones predefinidas para \code{number\_format} en cada llamada usando los parámetros adicionales.


\chapter{\texttt{url\_encode}}
\label{filters/url_encode:url-encode}\label{filters/url_encode::doc}\label{filters/url_encode:id1}
El filtro \code{url\_encode} produce una cadena \emph{URL} codificada.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{data}\PYG{o}{\textbar{}}\PYG{n+nf}{url\PYGZus{}encode}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Internamente, \emph{Twig} utiliza la función \href{http://mx2.php.net/manual/es/function.urlencode.php}{urlencode} de \emph{PHP}.
\end{notice}


\chapter{\texttt{json\_encode}}
\label{filters/json_encode:urlencode}\label{filters/json_encode::doc}\label{filters/json_encode:json-encode}
El filtro \code{json\_encode} devuelve la representación \emph{JSON} de una cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{data}\PYG{o}{\textbar{}}\PYG{n+nf}{json\PYGZus{}encode}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Internamente, \emph{Twig} utiliza la función \href{http://mx.php.net/json\_encode}{json\_encode} de \emph{PHP}.
\end{notice}


\chapter{\texttt{convert\_encoding}}
\label{filters/convert_encoding::doc}\label{filters/convert_encoding:convert-encoding}\label{filters/convert_encoding:id1}Nuevo en la versión 1.4: El filtro \code{convert\_encoding} se añadió en \emph{Twig} 1.4.
El filtro \code{convert\_encoding} convierte una cadena de una codificación a otra. El primer argumento es el juego de caracteres esperado y el segundo es el juego de caracteres de entrada:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{data}\PYG{o}{\textbar{}}\PYG{n+nf}{convert\PYGZus{}encoding}\PYG{o}{(}\PYG{l+s+s1}{'UTF-8'}\PYG{o}{,} \PYG{l+s+s1}{'iso-2022-jp'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Este filtro está basado en la extensión \href{http://mx.php.net/iconv}{iconv} o \href{http://mx2.php.net/mbstring}{mbstring}, por lo tanto tienes que instalar una de ellas. En caso que tengas instaladas ambas, por omisión se utiliza \href{http://mx.php.net/iconv}{iconv}.
\end{notice}


\chapter{\texttt{title}}
\label{filters/title::doc}\label{filters/title:mbstring}\label{filters/title:title}
El filtro \code{title} devuelve una versión con mayúsculas iniciales del valor. Es decir, las palabras deben empezar con letras mayúsculas, todos los caracteres restantes son minúsculas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'mi primer automóvil'}\PYG{o}{\textbar{}}\PYG{n+nf}{title} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce 'Mi Primer Automóvil' \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{capitalize}}
\label{filters/capitalize:capitalize}\label{filters/capitalize::doc}
El filtro \code{capitalize} capitaliza un valor. El primer carácter será en mayúscula, todos los demás en minúsculas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'my first car'}\PYG{o}{\textbar{}}\PYG{n+nf}{capitalize} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce 'My first car' \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{nl2br}}
\label{filters/nl2br:nl2br}\label{filters/nl2br::doc}Nuevo en la versión 1.5: El filtro \code{nl2br} se añadió en \emph{Twig} 1.5.
El filtro \code{nl2br} inserta saltos de línea \emph{HTML} antes de todas las nuevas líneas en una cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s2}{"I like Twig.\PYGZbs{}nYou will like it too."}\PYG{o}{\textbar{}}\PYG{n+nf}{nl2br} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c}{\PYGZob{}\PYGZsh{} produce}

\PYG{c}{    I like Twig.\textless{}br /\textgreater{}}
\PYG{c}{    You will like it too.}

\PYG{c}{\PYGZsh{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
El filtro \code{nl2br} primero escapa la entrada antes de aplicar la transformación.
\end{notice}


\chapter{\texttt{upper}}
\label{filters/upper:upper}\label{filters/upper::doc}
El filtro \code{upper} convierte un valor a mayúsculas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'bienvenido'}\PYG{o}{\textbar{}}\PYG{n+nf}{upper} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce 'BIENVENIDO' \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{lower}}
\label{filters/lower:lower}\label{filters/lower::doc}
El filtro \code{lower} convierte un valor a minúsculas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'BIENVENIDO'}\PYG{o}{\textbar{}}\PYG{n+nf}{lower} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce 'bienvenido' \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{striptags}}
\label{filters/striptags:striptags}\label{filters/striptags::doc}
El filtro \code{striptags} quita etiquetas \emph{SGML/XML} y sustituye los espacios en blanco adyacentes por un espacio:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{some\PYGZus{}html}\PYG{o}{\textbar{}}\PYG{n+nf}{striptags} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Internamente, \emph{Twig} utiliza la función \href{http://mx.php.net/strip\_tags}{strip\_tags} de \emph{PHP}.
\end{notice}


\chapter{\texttt{join}}
\label{filters/join:join}\label{filters/join::doc}\label{filters/join:strip-tags}
El filtro \code{join} devuelve una cadena que es la concatenación de las cadenas de una secuencia:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{]}\PYG{o}{\textbar{}}\PYG{n+nf}{join} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c}{\PYGZob{}\PYGZsh{} devuelve 123 \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

El separador predeterminado entre los elementos es una cadena vacía, lo puedes definir con el primer parámetro opcional:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{]}\PYG{o}{\textbar{}}\PYG{n+nf}{join}\PYG{o}{(}\PYG{l+s+s1}{'\textbar{}'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c}{\PYGZob{}\PYGZsh{} devuelve 1\textbar{}2\textbar{}3 \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{reverse}}
\label{filters/reverse::doc}\label{filters/reverse:reverse}Nuevo en la versión 1.6: La compatibilidad para cadenas se añadió en \emph{Twig} 1.6.
El filtro \code{reverse} invierte una secuencia, una matriz asociativa, o una cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{use} \PYG{k}{in} \PYG{n+nv}{users}\PYG{o}{\textbar{}}\PYG{n+nf}{reverse} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'1234'}\PYG{o}{\textbar{}}\PYG{n+nf}{reverse} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} outputs 4321 \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Además trabaja con objetos que implementan la interfaz \href{http://php.net/Traversable}{Traversable}.
\end{notice}


\chapter{\texttt{length}}
\label{filters/length:traversable}\label{filters/length::doc}\label{filters/length:length}
El filtro \code{length} devuelve el número de elementos de una secuencia o asignación, o la longitud de una cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{users}\PYG{o}{\textbar{}}\PYG{n+nf}{length} \PYG{o}{\textgreater{}} \PYG{l+m}{1}\PYG{l+m}{0} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{sort}}
\label{filters/sort:sort}\label{filters/sort::doc}
El filtro \code{sort} ordena una matriz:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{use} \PYG{k}{in} \PYG{n+nv}{users}\PYG{o}{\textbar{}}\PYG{n+nf}{sort} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Internamente, \emph{Twig} utiliza la función \href{http://mx.php.net/asort}{asort} de \emph{PHP} para mantener asociado el índice.
\end{notice}


\chapter{\texttt{default}}
\label{filters/default:default}\label{filters/default::doc}\label{filters/default:asort}
El filtro \code{default} devuelve el valor pasado como predeterminado si el valor no está definido o está vacío, de lo contrario devuelve el valor de la variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'var no está definido'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{n+nv}{.foo}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'el elemento foo en var no está definido'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{[}\PYG{l+s+s1}{'foo'}\PYG{o}{]}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'el elemento foo en var no está definido'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{''}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'la variable pasada está vacía'}\PYG{o}{)}  \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Cuando usas el filtro \code{default} en una expresión que usa variables en alguna llamada a método, asegúrate de usar el filtro \code{default} cuando no se haya definido una variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{n+nv}{.method}\PYG{o}{(}\PYG{n+nv}{foo}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'foo'}\PYG{o}{)}\PYG{o}{)}\PYG{o}{\textbar{}}\PYG{n+nf}{default}\PYG{o}{(}\PYG{l+s+s1}{'foo'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Lee más adelante la documentación de las pruebas {\hyperref[tests/defined::doc]{\emph{defined}}} (\autopageref*{tests/defined::doc}) y {\hyperref[tests/empty::doc]{\emph{empty}}} (\autopageref*{tests/empty::doc}) para aprender más acerca de su semántica.
\end{notice}


\chapter{\texttt{keys}}
\label{filters/keys:keys}\label{filters/keys::doc}
El filtro \code{keys} devuelve las claves de una matriz. Es útil cuando deseas iterar sobre las claves de una matriz:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{key} \PYG{k}{in} \PYG{n+nv}{array}\PYG{o}{\textbar{}}\PYG{n+nf}{keys} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{escape}}
\label{filters/escape::doc}\label{filters/escape:escape}
El filtro \code{escape} convierte los caracteres \code{\&}, \code{\textless{}}, \code{\textgreater{}}, \code{'} y \code{"} de cadenas a secuencias \emph{HTML} seguras. Utiliza esta opción si necesitas mostrar texto que puede contener tales caracteres \emph{HTML}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{escape} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Por conveniencia, el filtro \code{e} está definido como un alias:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Además, puedes usar el filtro \code{escape} fuera del contexto \emph{HTML} gracias al argumento opcional que define la estrategia de escape a usar:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c}{\PYGZob{}\PYGZsh{} es equivalente a \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e}\PYG{o}{(}\PYG{l+s+s1}{'html'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Y aquí tienes cómo escapar variables incluidas en código \emph{JavaScript}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{escape}\PYG{o}{(}\PYG{l+s+s1}{'js'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user}\PYG{n+nv}{.username}\PYG{o}{\textbar{}}\PYG{n+nf}{e}\PYG{o}{(}\PYG{l+s+s1}{'js'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Internamente, \code{escape} utiliza la función \href{http://php.net/htmlspecialchars}{htmlspecialchars} nativa de \emph{PHP}.
\end{notice}


\chapter{\texttt{raw}}
\label{filters/raw:raw}\label{filters/raw::doc}\label{filters/raw:htmlspecialchars}
El filtro \code{raw} marca el valor como ``seguro'', lo cual significa que en un entorno con escape automático activado esta variable no será escapada siempre y cuando \code{raw} sea el último filtro que se le aplica:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{autoescape} \PYG{k+kp}{true} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var}\PYG{o}{\textbar{}}\PYG{n+nf}{raw} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} var won't be escaped \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endautoescape} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{merge}}
\label{filters/merge:merge}\label{filters/merge::doc}
El filtro \code{merge} combina una matriz con otra matriz:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{values} \PYG{o}{=} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{values} \PYG{o}{=} \PYG{n+nv}{values}\PYG{o}{\textbar{}}\PYG{n+nf}{merge}\PYG{o}{(}\PYG{o}{[}\PYG{l+s+s1}{'apple'}\PYG{o}{,} \PYG{l+s+s1}{'orange'}\PYG{o}{]}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} values ahora contiene [1, 2, 'apple', 'orange'] \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Los nuevos valores se añaden al final de los existentes.

El filtro \code{merge} también trabaja en \code{codificaciones}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{items} \PYG{o}{=} \PYG{o}{\PYGZob{}} \PYG{l+s+s1}{'apple'}\PYG{o}{:} \PYG{l+s+s1}{'fruit'}\PYG{o}{,}
                     \PYG{l+s+s1}{'orange'}\PYG{o}{:} \PYG{l+s+s1}{'fruit'}\PYG{o}{,}
                 \PYG{l+s+s1}{'peugeot'}\PYG{o}{:} \PYG{l+s+s1}{'unknown'} \PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{items} \PYG{o}{=} \PYG{n+nv}{items}\PYG{o}{\textbar{}}\PYG{n+nf}{merge}\PYG{o}{(}\PYG{o}{\PYGZob{}} \PYG{l+s+s1}{'peugeot'}\PYG{o}{:} \PYG{l+s+s1}{'car'}\PYG{o}{,}
                             \PYG{l+s+s1}{'renault'}\PYG{o}{:} \PYG{l+s+s1}{'car'} \PYG{o}{\PYGZcb{}}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} items ahora contiene \PYGZob{} 'apple': 'fruit',}
\PYG{c}{                     'orange': 'fruit',}
\PYG{c}{                 'peugeot': 'car',}
\PYG{c}{                             'renault': 'car' \PYGZcb{} \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Para las \code{codificaciones}, el proceso de combinación ocurre en las claves: si no existe la clave, se agrega, pero si la clave ya existe, su valor es reemplazado.

\begin{notice}{tip}{Truco:}
Si te quieres asegurar de que algunos valores están definidos en una matriz (por determinados valores preestablecidos), revierte los dos elementos en la llamada:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{items} \PYG{o}{=} \PYG{o}{\PYGZob{}} \PYG{l+s+s1}{'apple'}\PYG{o}{:} \PYG{l+s+s1}{'fruit'}\PYG{o}{,}
                 \PYG{l+s+s1}{'orange'}\PYG{o}{:} \PYG{l+s+s1}{'fruit'} \PYG{o}{\PYGZcb{}} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{items} \PYG{o}{=} \PYG{o}{\PYGZob{}} \PYG{l+s+s1}{'apple'}\PYG{o}{:} \PYG{l+s+s1}{'unknown'} \PYG{o}{\PYGZcb{}}\PYG{o}{\textbar{}}\PYG{n+nf}{merge}\PYG{o}{(}\PYG{n+nv}{items}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} items ahora contiene \PYGZob{} 'apple': 'fruit',}
\PYG{c}{                 'orange': 'fruit' \PYGZcb{} \PYGZsh{}\PYGZcb{}}
\end{Verbatim}
\end{notice}


\chapter{\texttt{slice}}
\label{filters/slice:slice}\label{filters/slice::doc}Nuevo en la versión 1.6: El filtro \code{slice} se añadió en \emph{Twig} 1.6.
El filtro \code{slice} extrae un segmento de una secuencia, una matriz asociativa, o una cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{,} \PYG{l+m}{4}\PYG{o}{]}\PYG{o}{\textbar{}}\PYG{n+nf}{slice}\PYG{o}{(}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} iterará en 2 y 3 \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'1234'}\PYG{o}{\textbar{}}\PYG{n+nf}{slice}\PYG{o}{(}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce 23 \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Puedes usar cualquier expresión válida tanto para \code{start} como para \code{length}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{,} \PYG{l+m}{4}\PYG{o}{]}\PYG{o}{\textbar{}}\PYG{n+nf}{slice}\PYG{o}{(}\PYG{n+nv}{start}\PYG{o}{,} \PYG{n+nv}{length}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} ... \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Como azúcar sintáctica, también puedes utilizar la notación \code{{[}{]}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{,} \PYG{l+m}{4}\PYG{o}{]}\PYG{o}{[}\PYG{n+nv}{start}\PYG{o}{:}\PYG{n+nv}{length}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} ... \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'1234'}\PYG{o}{[}\PYG{l+m}{1}\PYG{o}{:}\PYG{l+m}{2}\PYG{o}{]} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

El filtro \code{slice} trabaja como la función \code{array\_slice} de \emph{PHP} para las matrices y
\href{http://php.net/substr}{substr} para las cadenas.

Si \code{start} no es negativo, la secuencia iniciará en \code{start} en la variable. Si \code{start} es negativo, la secuencia comenzará en esa posición desde el final de la variable.

Si se especifica \code{length} y es positivo, entonces la secuencia tendrá hasta tantos elementos en ella. Si la variable es más corta que la longitud, entonces, sólo los elementos disponibles en la variable estarán presentes. Si se especifica \code{length} y es negativo, entonces la secuencia se detendrá hasta tantos elementos a partir del final de la variable. Si se omite, la secuencia tendrá todo desde el desplazamiento hasta el final de la variable.

\begin{notice}{note}{Nota:}
Además trabaja con objetos que implementan la interfaz \href{http://php.net/manual/en/class.traversable.php}{Traversable}.
\end{notice}


\chapter{\texttt{trim}}
\label{filters/trim:trim}\label{filters/trim:substr}\label{filters/trim::doc}Nuevo en la versión 1.6.2: El filtro \code{trim} se añadió en \emph{Twig} 1.6.2.
El filtro \code{trim} quita los espacios en blanco (u otros caracteres) del principio
y final de una cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'  Me gusta Twig.  '}\PYG{o}{\textbar{}}\PYG{n+nf}{trim} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce 'Me gusta Twig.' \PYGZsh{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{l+s+s1}{'  Me gusta Twig.'}\PYG{o}{\textbar{}}\PYG{n+nf}{trim}\PYG{o}{(}\PYG{l+s+s1}{'.'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} produce '  Me gusta Twig' \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Internamente, \emph{Twig} usa la función \href{http://php.net/trim}{trim} de \emph{PHP}.
\end{notice}


\part{Funciones}
\label{functions/index::doc}\label{functions/index:funciones}\label{functions/index:id1}

\chapter{\texttt{range}}
\label{functions/range:range}\label{functions/range::doc}
Devuelve una lista conteniendo una progresión aritmética de enteros:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{n+nv}{range}\PYG{o}{(}\PYG{l+m}{0}\PYG{o}{,} \PYG{l+m}{3}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{i} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{,}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} devuelve 0, 1, 2, 3 \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

Cuando se da el paso (como tercer parámetro), este especifica el incremento (o decremento):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{n+nv}{range}\PYG{o}{(}\PYG{l+m}{0}\PYG{o}{,} \PYG{l+m}{6}\PYG{o}{,} \PYG{l+m}{2}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{i} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{,}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} devuelve 0, 2, 4, 6 \PYGZsh{}\PYGZcb{}}
\end{Verbatim}

El operador integrado \code{..} es pura azúcar sintáctica para la función \code{range} (con un paso de 1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{l+m}{0.}\PYG{n+nv}{.3} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{i} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{,}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{tip}{Truco:}
La función \code{range} trabaja como la función \href{http://mx2.php.net/range}{range} nativa de \emph{PHP}.
\end{notice}


\chapter{\texttt{cycle}}
\label{functions/cycle:cycle}\label{functions/cycle::doc}\label{functions/cycle:id1}
Puedes utilizar la función \code{cycle} para recorrer un arreglo de valores:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{l+m}{0.}\PYG{n+nv}{.10} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{cycle}\PYG{o}{(}\PYG{o}{[}\PYG{l+s+s1}{'odd'}\PYG{o}{,} \PYG{l+s+s1}{'even'}\PYG{o}{]}\PYG{o}{,} \PYG{n+nv}{i}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La matriz puede contener cualquier cantidad de valores:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{set} \PYG{n+nv}{frutas} \PYG{o}{=} \PYG{o}{[}\PYG{l+s+s1}{'manzana'}\PYG{o}{,} \PYG{l+s+s1}{'naranja'}\PYG{o}{,} \PYG{l+s+s1}{'cítricos'}\PYG{o}{]} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{i} \PYG{k}{in} \PYG{l+m}{0.}\PYG{n+nv}{.10} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{cycle}\PYG{o}{(}\PYG{n+nv}{frutas}\PYG{o}{,} \PYG{n+nv}{i}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{constant}}
\label{functions/constant:constant}\label{functions/constant::doc}
\code{constant} devuelve el valor constante de una determinada cadena:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{some\PYGZus{}date}\PYG{o}{\textbar{}}\PYG{n+nf}{date}\PYG{o}{(}\PYG{n+nv}{constant}\PYG{o}{(}\PYG{l+s+s1}{'DATE\PYGZus{}W3C'}\PYG{o}{)}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{constant}\PYG{o}{(}\PYG{l+s+s1}{'Namespace\PYGZbs{}\PYGZbs{}Classname::CONSTANT\PYGZus{}NAME'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{random}}
\label{functions/random:random}\label{functions/random::doc}Nuevo en la versión 1.5: La función \code{random} se agregó en \emph{Twig} 1.5.Nuevo en la versión 1.6: Se añadió la manipulación de \code{string} e \code{integer} en \emph{Twig} 1.6.
La función \code{random} devuelve un valor al azar dependiendo del tipo de parámetro suministrado:
\begin{itemize}
\item {} 
un elemento al azar de una secuencia;

\item {} 
un carácter aleatorio de una cadena;

\item {} 
un entero al azar entre 0 y el parámetro entero (inclusive).

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{random}\PYG{o}{(}\PYG{o}{[}\PYG{l+s+s1}{'apple'}\PYG{o}{,}
           \PYG{l+s+s1}{'orange'}\PYG{o}{,}
           \PYG{l+s+s1}{'citrus'}\PYG{o}{]}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{ }\PYG{c}{\PYGZob{}\PYGZsh{} ejemplo de salida: orange \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{random}\PYG{o}{(}\PYG{l+s+s1}{'ABC'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{      }\PYG{c}{\PYGZob{}\PYGZsh{} ejemplo de salida: C \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{random}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{           }\PYG{c}{\PYGZob{}\PYGZsh{} ejemplo de salida: 15386094}
\PYG{c}{                            (trabaja como la función}
\PYG{c}{                            {}`mt\PYGZus{}rand{}`\PYGZus{} nativa de PHP) \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{random}\PYG{o}{(}\PYG{l+m}{5}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{          }\PYG{c}{\PYGZob{}\PYGZsh{} ejemplo de salida: 3 \PYGZsh{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{attribute}}
\label{functions/attribute:attribute}\label{functions/attribute::doc}\label{functions/attribute:mt-rand}Nuevo en la versión 1.2: La función \code{attribute} se añadió en \emph{Twig} 1.2.
Puedes usar \code{attribute} para acceder a los atributos ``dinámicos'' de una variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{attribute}\PYG{o}{(}\PYG{n+nv}{object}\PYG{o}{,} \PYG{n+nv}{method}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{attribute}\PYG{o}{(}\PYG{n+nv}{object}\PYG{o}{,} \PYG{n+nv}{method}\PYG{o}{,} \PYG{n+nv}{arguments}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{attribute}\PYG{o}{(}\PYG{n+nv}{array}\PYG{o}{,} \PYG{n+nv}{item}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
El algoritmo de resolución es el mismo que el utilizado para la notación de punto (''.''), salvo que el elemento puede ser cualquier expresión válida.
\end{notice}


\chapter{\texttt{block}}
\label{functions/block::doc}\label{functions/block:block}
Cuando una plantilla utiliza herencia y si deseas imprimir un bloque varias
veces, usa la función \code{block}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}title\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{title} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{x}{\textless{}/title\textgreater{}}

\PYG{x}{\textless{}h1\textgreater{}}\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nb}{block}\PYG{o}{(}\PYG{l+s+s1}{'title'}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{\textless{}/h1\textgreater{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{body} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\strong{Ver También:}


{\hyperref[tags/extends::doc]{\emph{extends}}} (\autopageref*{tags/extends::doc}), {\hyperref[functions/parent::doc]{\emph{parent}}} (\autopageref*{functions/parent::doc})




\chapter{\texttt{parent}}
\label{functions/parent::doc}\label{functions/parent:parent}
Cuando una plantilla utiliza herencia, es posible reproducir el contenido del
bloque padre cuando reemplaces un bloque usando la función \code{parent}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{extends} \PYG{l+s+s2}{"base.html"} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{block} \PYG{n+nv}{sidebar} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    \textless{}h3\textgreater{}Table Of Contents\textless{}/h3\textgreater{}}
\PYG{x}{    ...}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{parent}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endblock} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

La llamada a \code{parent()} devolverá el contenido del bloque \code{sidebar} como lo definimos en la plantilla \code{base.html}.


\strong{Ver También:}


{\hyperref[tags/extends::doc]{\emph{extends}}} (\autopageref*{tags/extends::doc}), {\hyperref[functions/block::doc]{\emph{block}}} (\autopageref*{functions/block::doc}), {\hyperref[tags/block::doc]{\emph{block}}} (\autopageref*{tags/block::doc})




\chapter{\texttt{dump}}
\label{functions/dump::doc}\label{functions/dump:dump}Nuevo en la versión 1.5: La función \code{dump} se añadió en \emph{Twig} 1.5.
La función \code{dump} vierte información sobre una variable de plantilla. Esta es útil principalmente para depurar una plantilla que no se comporta como se esperaba, permitiendo inspeccionar sus variables:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{dump}\PYG{o}{(}\PYG{n+nv}{user}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
La función \code{dump} de manera predefinida no esta disponible. la debes añadir explícitamente a la extensión \code{Twig\_Extension\_Debug} al crear tu entorno \emph{Twig}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{,} \PYG{k}{array}\PYG{p}{(}
    \PYG{l+s+s1}{'debug'} \PYG{o}{=\textgreater{}} \PYG{k}{true}\PYG{p}{,}
    \PYG{c+c1}{// ...}
\PYG{p}{));}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{addExtension}\PYG{p}{(}\PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Extension\PYGZus{}Debug}\PYG{p}{());}
\end{Verbatim}

Incluso al activarla, la función \code{dump} no muestra nada si la opción \code{debug} en el entorno no está activada (para evitar fugas de información al depurar en un servidor en producción).
\end{notice}

En un contexto \emph{HTML}, envuelve su resultado en una etiqueta \code{pre} para facilitar su lectura:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{\textless{}pre\textgreater{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{dump}\PYG{o}{(}\PYG{n+nv}{user}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\PYG{x}{\textless{}/pre\textgreater{}}
\end{Verbatim}

\begin{notice}{tip}{Truco:}
No es necesario usar una etiqueta \code{pre} cuando \href{http://xdebug.org/docs/display}{XDebug} está activado y \code{html\_errors} es \code{on}; como bono adicional, el resultado también se mejora con \code{XDebug} activado.
\end{notice}

Puedes depurar muchas variables pasándolas como argumentos adicionales:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{dump}\PYG{o}{(}\PYG{n+nv}{user}\PYG{o}{,} \PYG{n+nv}{categories}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

Si no pasas ningún valor, se vierten todas las variables del contexto actual:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{dump}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Internamente, \emph{Twig} usa la función \href{http://php.net/var\_dump}{var\_dump} de \emph{PHP}.
\end{notice}


\chapter{\texttt{date}}
\label{functions/date:date}\label{functions/date::doc}\label{functions/date:var-dump}Nuevo en la versión 1.6: La función \code{date} se añadió en \emph{Twig} 1.6.Nuevo en la versión 1.6.1: El soporte para la zona horaria predeterminada se añadió en \emph{Twig} 1.6.1
Convierte un argumento a una fecha para permitir comparación de fechas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{date}\PYG{o}{(}\PYG{n+nv}{user}\PYG{n+nv}{.created\PYGZus{}at}\PYG{o}{)} \PYG{o}{\textless{}} \PYG{n+nv}{date}\PYG{o}{(}\PYG{l+s+s1}{'+2days'}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} hace algo interesante \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

El argumento debe estar en un formato compatible con la función \href{http://www.php.net/date}{date}.

Puedes pasar una zona horaria como segundo argumento:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{date}\PYG{o}{(}\PYG{n+nv}{user}\PYG{n+nv}{.created\PYGZus{}at}\PYG{o}{)} \PYG{o}{\textless{}} \PYG{n+nv}{date}\PYG{o}{(}\PYG{l+s+s1}{'+2days'}\PYG{o}{,} \PYG{l+s+s1}{'Europe/Paris'}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} hace algo interesante \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Si no suministras ningún argumento, la función devuelve la fecha actual:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{date}\PYG{o}{(}\PYG{n+nv}{user}\PYG{n+nv}{.created\PYGZus{}at}\PYG{o}{)} \PYG{o}{\textless{}} \PYG{n+nv}{date}\PYG{o}{(}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} ¡siempre! \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
Puedes configurar la zona horaria globalmente llamando a \code{setTimezone()} en la instancia de la extensión \code{core}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}twig} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Twig\PYGZus{}Environment}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}loader}\PYG{p}{);}
\PYG{n+nv}{\PYGZdl{}twig}\PYG{o}{-\textgreater{}}\PYG{n+na}{getExtension}\PYG{p}{(}\PYG{l+s+s1}{'core'}\PYG{p}{)}\PYG{o}{-\textgreater{}}\PYG{n+na}{setTimezone}\PYG{p}{(}\PYG{l+s+s1}{'Europe/Paris'}\PYG{p}{);}
\end{Verbatim}
\end{notice}


\part{Probando}
\label{tests/index:probando}\label{tests/index::doc}\label{tests/index:id1}

\chapter{\texttt{divisibleby}}
\label{tests/divisibleby:divisibleby}\label{tests/divisibleby::doc}
\code{divisibleby} comprueba si una variable es divisible por un número:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nb}{loop}\PYG{n+nv}{.index} \PYG{k}{is} \PYG{n+nf}{divisibleby}\PYG{o}{(}\PYG{l+m}{3}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{null}}
\label{tests/null:null}\label{tests/null::doc}
\code{null} devuelve \code{true} si la variable es \code{null}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var} \PYG{k}{is} \PYG{n+nf}{null} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Nota:}
\code{none} es un alias para \code{null}.
\end{notice}


\chapter{\texttt{even}}
\label{tests/even:even}\label{tests/even::doc}
\code{even} devuelve \code{true} si el número dado es par:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var} \PYG{k}{is} \PYG{n+nf}{even} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}


\strong{Ver También:}


{\hyperref[tests/odd::doc]{\emph{odd}}} (\autopageref*{tests/odd::doc})




\chapter{\texttt{odd}}
\label{tests/odd:odd}\label{tests/odd::doc}
\code{odd} devuelve \code{true} si el número dado es impar:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{var} \PYG{k}{is} \PYG{n+nf}{odd} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}
\end{Verbatim}


\strong{Ver También:}


{\hyperref[tests/even::doc]{\emph{even}}} (\autopageref*{tests/even::doc})




\chapter{\texttt{sameas}}
\label{tests/sameas:sameas}\label{tests/sameas::doc}
\code{sameas} comprueba si una variable apunta a la misma dirección de memoria que otra variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{foo}\PYG{n+nv}{.attribute} \PYG{k}{is} \PYG{n+nf}{sameas}\PYG{o}{(}\PYG{k+kp}{false}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    el atributo de foo, en realidad es el valor 'false' de PHP}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{constant}}
\label{tests/constant:constant}\label{tests/constant::doc}
\code{constant} comprueba si una variable tiene el mismo valor exacto que una constante. Puedes utilizar cualquiera de las constantes globales o constantes de clase:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{post}\PYG{n+nv}{.status} \PYG{k}{is} \PYG{n+nf}{constant}\PYG{o}{(}\PYG{l+s+s1}{'Post::PUBLISHED'}\PYG{o}{)} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    el atributo estatus es exactamente el mismo que Post::PUBLISHED}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{defined}}
\label{tests/defined:defined}\label{tests/defined::doc}
\code{defined} comprueba si una variable está definida en el contexto actual. Esto es muy útil si utilizas la opción \code{strict\_variables}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} defined trabaja con nombres de variable \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{foo} \PYG{k}{is} \PYG{n+nf}{defined} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c}{\PYGZob{}\PYGZsh{} y atributos en nombres de variables \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{foo}\PYG{n+nv}{.bar} \PYG{k}{is} \PYG{n+nf}{defined} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}

\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{foo}\PYG{o}{[}\PYG{l+s+s1}{'bar'}\PYG{o}{]} \PYG{k}{is} \PYG{n+nf}{defined} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}

Cuando uses la prueba \code{defined} en una expresión que usa variables en alguna llamada a método, primero asegúrate de haberlas definido:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{var} \PYG{k}{is} \PYG{n+nf}{defined} \PYG{k}{and} \PYG{n+nv}{foo}\PYG{n+nv}{.method}\PYG{o}{(}\PYG{n+nv}{var}\PYG{o}{)} \PYG{k}{is} \PYG{n+nf}{defined} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{empty}}
\label{tests/empty::doc}\label{tests/empty:empty}
\code{empty} comprueba si una variable está vacía:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} evalúa a true si la variable foo es null, false o la}
\PYG{c}{   cadena vacía \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{foo} \PYG{k}{is} \PYG{n+nf}{empty} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    ...}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}


\chapter{\texttt{iterable}}
\label{tests/iterable::doc}\label{tests/iterable:iterable}Nuevo en la versión 1.7: La prueba \code{iterable} se añadió en \emph{Twig 1.7}.
\code{iterable} comprueba si una variable es una matriz o un objeto transitable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZob{}\PYGZsh{} evalúa a true si la variable foo es iterable \PYGZsh{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{if} \PYG{n+nv}{users} \PYG{k}{is} \PYG{n+nf}{iterable} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{for} \PYG{n+nv}{user} \PYG{k}{in} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{        Hello }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{user} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{!}
\PYG{x}{    }\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endfor} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{else} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\PYG{x}{    }\PYG{c}{\PYGZob{}\PYGZsh{} probablemente users sea una cadena \PYGZsh{}\PYGZcb{}}
\PYG{x}{    Hello }\PYG{c+cp}{\PYGZob{}\PYGZob{}} \PYG{n+nv}{users} \PYG{c+cp}{\PYGZcb{}\PYGZcb{}}\PYG{x}{!}
\PYG{c+cp}{\PYGZob{}\PYGZpc{}} \PYG{k}{endif} \PYG{c+cp}{\PYGZpc{}\PYGZcb{}}
\end{Verbatim}



\renewcommand{\indexname}{Índice}
\printindex
\end{document}
